(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{501:function(module,exports){},710:function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__);__webpack_require__(335)},901:function(module,exports,__webpack_require__){"use strict";var _clientApi=__webpack_require__(153),_clientLogger=__webpack_require__(71),_configFilename=__webpack_require__(941);function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach((function(key){_defineProperty(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}(_configFilename.args||_configFilename.argTypes)&&_clientLogger.logger.warn("Invalid args/argTypes in config, ignoring.",JSON.stringify({args:_configFilename.args,argTypes:_configFilename.argTypes})),_configFilename.decorators&&_configFilename.decorators.forEach((function(decorator){return(0,_clientApi.addDecorator)(decorator,!1)})),_configFilename.loaders&&_configFilename.loaders.forEach((function(loader){return(0,_clientApi.addLoader)(loader,!1)})),(_configFilename.parameters||_configFilename.globals||_configFilename.globalTypes)&&(0,_clientApi.addParameters)(_objectSpread(_objectSpread({},_configFilename.parameters),{},{globals:_configFilename.globals,globalTypes:_configFilename.globalTypes}),!1),_configFilename.argTypesEnhancers&&_configFilename.argTypesEnhancers.forEach((function(enhancer){return(0,_clientApi.addArgTypesEnhancer)(enhancer)}))},904:function(module,exports,__webpack_require__){"use strict";(function(module){(0,__webpack_require__(335).configure)([__webpack_require__(905)],module,!1)}).call(this,__webpack_require__(152)(module))},905:function(module,exports,__webpack_require__){var map={"./index.stories.tsx":940};function webpackContext(req){var id=webpackContextResolve(req);return __webpack_require__(id)}function webpackContextResolve(req){if(!__webpack_require__.o(map,req)){var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}return map[req]}webpackContext.keys=function webpackContextKeys(){return Object.keys(map)},webpackContext.resolve=webpackContextResolve,module.exports=webpackContext,webpackContext.id=905},940:function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,"SingleSelect",(function(){return index_stories_SingleSelect})),__webpack_require__.d(__webpack_exports__,"MultiSelect",(function(){return index_stories_MultiSelect})),__webpack_require__.d(__webpack_exports__,"Styling",(function(){return index_stories_Styling})),__webpack_require__.d(__webpack_exports__,"Events",(function(){return index_stories_Events})),__webpack_require__.d(__webpack_exports__,"Methods",(function(){return index_stories_Methods})),__webpack_require__.d(__webpack_exports__,"Filtering",(function(){return index_stories_Filtering})),__webpack_require__.d(__webpack_exports__,"Windowing",(function(){return index_stories_Windowing})),__webpack_require__.d(__webpack_exports__,"Advanced",(function(){return index_stories_Advanced})),__webpack_require__.d(__webpack_exports__,"Async",(function(){return index_stories_Async}));var toConsumableArray=__webpack_require__(104),objectSpread2=__webpack_require__(27),slicedToArray=__webpack_require__(5),defineProperty=__webpack_require__(64),jsx_runtime=__webpack_require__(0),react=__webpack_require__(1),react_toastify_esm=__webpack_require__(136),useUpdateEffect=__webpack_require__(401),useCallbackState_useCallbackState=function useCallbackState(initialState){var _useState=Object(react.useState)(initialState),_useState2=Object(slicedToArray.a)(_useState,2),state=_useState2[0],setState=_useState2[1];return[state,Object(react.useCallback)((function(newState){return setState(newState)}),[])]},Select=__webpack_require__(954),enums=__webpack_require__(16),taggedTemplateLiteral=__webpack_require__(3),regenerator=__webpack_require__(245),regenerator_default=__webpack_require__.n(regenerator),asyncToGenerator=__webpack_require__(399),utils_renderInfoToast=function renderInfoToast(message){react_toastify_esm.a.info(message)},stringifyJavaScriptObj=function stringifyJavaScriptObj(data){return JSON.stringify(data||{},null,2).replace(/"(\w+)"\s*:/g,"$1:").replace(/"/g,"'")},createSelectOptions=function createSelectOptions(optionCount){for(var results=[],i=0;i<optionCount;i+=1)results.push({value:i+1,label:"Option ".concat(i+1)});return results},createAsyncOptions=function createAsyncOptions(optionCount,labelSuffix){return createSelectOptions(optionCount).map((function(option){return{value:"".concat(option.value).concat(labelSuffix),label:"".concat(option.label," - ").concat(labelSuffix)}}))};function _mockHttpRequest(){return(_mockHttpRequest=Object(asyncToGenerator.a)(regenerator_default.a.mark((function _callee(){var delay,_args=arguments;return regenerator_default.a.wrap((function _callee$(_context){for(;;)switch(_context.prev=_context.next){case 0:return delay=_args.length>0&&void 0!==_args[0]?_args[0]:500,_context.next=3,new Promise((function(resolve){return setTimeout(resolve,delay)}));case 3:case"end":return _context.stop()}}),_callee)})))).apply(this,arguments)}var numberWithCommas=function numberWithCommas(value){return value.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",")},styled_components_browser_esm=__webpack_require__(2);function _templateObject4(){var data=Object(taggedTemplateLiteral.a)(['\n  z-index: 0;\n  width: 1rem;\n  height: 1rem;\n  position: absolute;\n  border-style: solid;\n  border-width: 1.5px;\n  box-sizing: border-box;\n  border-radius: 0.0625rem;\n  background-color: transparent;\n  border-color: rgba(0, 0, 0, 0.54);\n  transition: border-color 0.365s ease;\n\n  :after,\n  :before {\n    height: 0;\n    opacity: 0;\n    content: "";\n    width: 0.2rem;\n    display: block;\n    position: absolute;\n    border-radius: 0.25rem;\n    transform-origin: left top;\n    background-color: ',";\n    transition: opacity 0.365s ease, height 0s linear 0.365s;\n  }\n\n  :after {\n    top: 0.33rem;\n    left: 0.01rem;\n    transform: rotate(-45deg);\n  }\n\n  :before {\n    top: 0.68rem;\n    left: 0.39rem;\n    transform: rotate(-135deg);\n  }\n"]);return _templateObject4=function _templateObject4(){return data},data}function _templateObject3(){var data=Object(taggedTemplateLiteral.a)(["\n  user-select: none;\n  position: relative;\n  margin-top: 0.5rem;\n  align-items: center;\n  display: inline-flex;\n\n  ","\n"]);return _templateObject3=function _templateObject3(){return data},data}function _templateObject2(){var data=Object(taggedTemplateLiteral.a)(["\n  z-index: 3;\n  opacity: 0;\n  width: 1em;\n  height: 1em;\n  cursor: pointer;\n  position: absolute;\n\n  :checked ~ i {\n    border-color: ",";\n\n    :after,\n    :before {\n      opacity: 1;\n      transition: height 0.365s ease;\n    }\n\n    :after {\n      height: 0.5rem;\n    }\n\n    :before {\n      height: 1.16rem;\n      transition-delay: 0.135s;\n    }\n  }\n"]);return _templateObject2=function _templateObject2(){return data},data}function _templateObject(){var data=Object(taggedTemplateLiteral.a)(["\n  user-select: none;\n  margin-left: 1.6rem;\n"]);return _templateObject=function _templateObject(){return data},data}var _colorBorderChecked=function hexToRgba(hex){var alpha=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,hexReplacer=hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,(function(m,r,g,b){return"#".concat(r).concat(r).concat(g).concat(g).concat(b).concat(b)})),alphaValid=Math.min(1,Math.max(0,alpha)),rgbaParts=[].concat(Object(toConsumableArray.a)(hexReplacer.substring(1).match(/.{2}/g).map((function(x){return parseInt(x,16)}))),[alphaValid]);return"rgba(".concat(rgbaParts.join(","),")")}("#149DF3",.78),Label=styled_components_browser_esm.d.span(_templateObject()),Input=styled_components_browser_esm.d.input(_templateObject2(),_colorBorderChecked),CheckboxWrapper=styled_components_browser_esm.d.label(_templateObject3(),(function(_ref){return _ref.isReadOnly&&"\n      cursor: default;\n      pointer-events: none;\n      > i {\n        opacity: 0.5;\n      }\n    "})),CheckIcon=styled_components_browser_esm.d.i(_templateObject4(),"#149DF3"),components_Checkbox=Object(react.memo)((function(_ref2){var label=_ref2.label,onCheck=_ref2.onCheck,checked=_ref2.checked,readOnly=_ref2.readOnly;return Object(jsx_runtime.jsxs)(CheckboxWrapper,{isReadOnly:readOnly,children:[Object(jsx_runtime.jsx)(Input,{type:"checkbox",checked:checked,onChange:function onChange(e){return onCheck(e.target.checked)}}),Object(jsx_runtime.jsx)(CheckIcon,{}),label&&Object(jsx_runtime.jsx)(Label,{children:label})]})})),dark=__webpack_require__(953),prism_light=__webpack_require__(955);function _templateObject28(){var data=Object(taggedTemplateLiteral.a)(["\n  color: #515151;\n  font-size: 1em;\n  font-weight: 600;\n  margin-left: 1px;\n  margin-bottom: 1.5px;\n"]);return _templateObject28=function _templateObject28(){return data},data}function _templateObject27(){var data=Object(taggedTemplateLiteral.a)(["\n  height: 100%;\n  display: flex;\n  align-items: center;\n  flex-direction: row;\n"]);return _templateObject27=function _templateObject27(){return data},data}function _templateObject26(){var data=Object(taggedTemplateLiteral.a)(["\n  width: 14px;\n  height: 14px;\n  fill: currentColor;\n  transition: transform 0.25s ease-in-out;\n  ","\n"]);return _templateObject26=function _templateObject26(){return data},data}function _templateObject25(){var data=Object(taggedTemplateLiteral.a)(["\n  width: 34px;\n  height: 34px;\n  color: #1ea7fd;\n  fill: currentColor;\n  display: inline-block;\n  ","\n"]);return _templateObject25=function _templateObject25(){return data},data}function _templateObject24(){var data=Object(taggedTemplateLiteral.a)(["animation: "," infinite 8s linear;"]);return _templateObject24=function _templateObject24(){return data},data}function _templateObject23(){var data=Object(taggedTemplateLiteral.a)(["\n  from {\n    transform: rotate(0deg);\n  } to {\n    transform: rotate(360deg);\n  }\n"]);return _templateObject23=function _templateObject23(){return data},data}function _templateObject22(){var data=Object(taggedTemplateLiteral.a)(["\n  opacity: 0.75;\n  font-size: 0.75em;\n  margin-top: 0.05em;\n  margin-left: 0.45em;\n"]);return _templateObject22=function _templateObject22(){return data},data}function _templateObject21(){var data=Object(taggedTemplateLiteral.a)(["\n  flex: 1 1 auto;\n  min-height: 32rem;\n  padding: 0.75rem 1.25rem;\n\n  "," {\n    padding: 0.75rem 0;\n  }\n"]);return _templateObject21=function _templateObject21(){return data},data}function _templateObject20(){var data=Object(taggedTemplateLiteral.a)(["\n  display: flex;\n  font-size: 1.15rem;\n  flex-flow: row wrap;\n  background-color: #fff;\n  padding: 0.75rem 1.25rem;\n  border-top-left-radius: 0.25rem;\n  border-top-right-radius: 0.25rem;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.125);\n\n  "," {\n    font-size: 1.1rem;\n    text-align: center;\n    display: inline-block;\n    padding: 0 1.3rem 1rem;\n  }\n"]);return _templateObject20=function _templateObject20(){return data},data}function _templateObject19(){var data=Object(taggedTemplateLiteral.a)(["\n  min-width: 0;\n  display: flex;\n  margin: 1.25rem 0;\n  position: relative;\n  word-wrap: break-word;\n  border-radius: 0.25rem;\n  background-color: #fff;\n  flex-direction: column;\n  background-clip: border-box;\n  border: 1px solid rgba(0, 0, 0, 0.125);\n  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.1);\n\n  "," {\n    border: none;\n    border-radius: 0;\n    box-shadow: none;\n    margin: 0;\n  }\n"]);return _templateObject19=function _templateObject19(){return data},data}function _templateObject18(){var data=Object(taggedTemplateLiteral.a)(["\n  font-size: 1rem;\n\n  > label {\n    margin-top: 0.5rem;\n    margin-bottom: 0.5rem;\n\n    :not(:last-of-type) {\n      margin-right: 1.35rem;\n    }\n  }\n\n  "," {\n    text-align: left;\n\n    > label {\n      width: 100%;\n      margin-left: auto;\n      margin-top: 0.5rem;\n      margin-bottom: 0.5rem;\n    }\n  }\n"]);return _templateObject18=function _templateObject18(){return data},data}function _templateObject17(){var data=Object(taggedTemplateLiteral.a)(["\n  width: 100%;\n  font-weight: 600;\n  text-align: left;\n  user-select: none;\n  display: inline-block;\n  vertical-align: middle;\n  color: rgba(0, 0, 0, 0.54);\n  margin: 0.5rem auto 0.25rem 0;\n\n  "," {\n    margin: 0 auto 0.15rem 0;\n  }\n"]);return _templateObject17=function _templateObject17(){return data},data}function _templateObject16(){var data=Object(taggedTemplateLiteral.a)(["\n  > button {\n    min-width: 4.5rem;\n    margin-top: 0.5rem;\n\n    :not(:last-of-type) {\n      margin-right: 0.5rem;\n    }\n  }\n"]);return _templateObject16=function _templateObject16(){return data},data}function _templateObject15(){var data=Object(taggedTemplateLiteral.a)(["\n  border: 0;\n  color: #212428;\n  cursor: pointer;\n  font-size: 1rem;\n  font-weight: 400;\n  line-height: 1.5;\n  overflow: visible;\n  user-select: none;\n  text-align: center;\n  border-radius: 3px;\n  display: inline-block;\n  vertical-align: middle;\n  padding: 0.375rem 0.75rem;\n  -webkit-appearance: button;\n  background-color: rgba(9, 30, 66, 0.075);\n  transition: color 0.2s ease-out, background-color 0.2s ease-out;\n\n  :focus {\n    outline: 0;\n  }\n\n  :hover, :focus {\n    background-color: rgba(9, 30, 66, 0.125);\n  }\n\n  "," {\n    display: block;\n    width: 100% !important;\n  }\n\n  "," {\n    font-size: 0.9em;\n  }\n"]);return _templateObject15=function _templateObject15(){return data},data}function _templateObject14(){var data=Object(taggedTemplateLiteral.a)(["\n  font-weight: 600;\n  line-height: 1.167;\n  font-size: 1.65rem;\n  margin-top: 1.25rem;\n  margin-bottom: 0.5rem;\n  letter-spacing: 0.00735em;\n"]);return _templateObject14=function _templateObject14(){return data},data}function _templateObject13(){var data=Object(taggedTemplateLiteral.a)(["\n  font-size: 2rem;\n  font-weight: 600;\n  line-height: 1.167;\n  margin-top: 0.5rem;\n  margin-bottom: .5rem;\n"]);return _templateObject13=function _templateObject13(){return data},data}function _templateObject12(){var data=Object(taggedTemplateLiteral.a)(["\n  color: black;\n  font-weight: 600;\n  line-height: 1.6;\n  font-size: 1.025em;\n  word-break: break-word;\n  padding: 3px 0 3px 6.4px;\n\n  "," {\n    padding: .1em .25em .1em;\n  }\n"]);return _templateObject12=function _templateObject12(){return data},data}function _templateObject11(){var data=Object(taggedTemplateLiteral.a)(["\n  display: list-item;\n  text-align: match-parent;\n"]);return _templateObject11=function _templateObject11(){return data},data}function _templateObject10(){var data=Object(taggedTemplateLiteral.a)(["\n  display: block;\n  padding-left: 1.75rem;\n  margin-block-end: 1em;\n  list-style-type: disc;\n  margin-inline-end: 0px;\n  margin-block-start: 1em;\n  margin-inline-start: 0px;\n  padding-inline-start: 30px;\n\n  li + li {\n    margin-top: 0.55em;\n  }\n\n  "," {\n    padding-inline-start: 20px;\n  }\n"]);return _templateObject10=function _templateObject10(){return data},data}function _templateObject9(){var data=Object(taggedTemplateLiteral.a)(["\n  ","\n\n  "," {\n    max-width: 85%;\n  }\n\n  &.is-class-list {\n    font-weight: 500;\n    max-width: 100% !important;\n\n    ul {\n      li + li {\n        margin-top: 0.8em !important;\n      }\n    }\n  }\n"]);return _templateObject9=function _templateObject9(){return data},data}function _templateObject8(){var data=Object(taggedTemplateLiteral.a)(["\n  flex-grow: 1;\n  flex-basis: 0;\n  flex-shrink: 1;\n  display: block;\n  padding: 0.25rem;\n\n  "," {\n    padding: 0.25rem 0;\n    width: 100% !important;\n  }\n\n  ","\n"]);return _templateObject8=function _templateObject8(){return data},data}function _templateObject7(){var data=Object(taggedTemplateLiteral.a)(["\n  width: 100%;\n\n  "," {\n    display: flex;\n  }\n"]);return _templateObject7=function _templateObject7(){return data},data}function _templateObject6(){var data=Object(taggedTemplateLiteral.a)(["\n  border: 0;\n  margin-top: 1rem;\n  margin-bottom: 1rem;\n  padding-bottom: .225rem;\n  border-top: 1px solid #ddd;\n"]);return _templateObject6=function _templateObject6(){return data},data}function _templateObject5(){var data=Object(taggedTemplateLiteral.a)(["\n  width: 60%;\n  margin-top: 1rem;\n\n  "," {\n    width: 75%;\n  }\n\n  "," {\n    width: 100%;\n  }\n"]);return _templateObject5=function _templateObject5(){return data},data}function styled_templateObject4(){var data=Object(taggedTemplateLiteral.a)(["\n  width: 100%;\n  display: block;\n  margin-left: auto;\n  margin-right: auto;\n  padding: 0.25rem 1.75rem;\n\n  "," {\n    font-size: 0.96em;\n    padding: 0.25rem 1.25rem;\n  }\n"]);return styled_templateObject4=function _templateObject4(){return data},data}function styled_templateObject3(){var data=Object(taggedTemplateLiteral.a)(["\n  ","\n\n  "," {\n    max-width: 85%;\n  }\n"]);return styled_templateObject3=function _templateObject3(){return data},data}function styled_templateObject2(){var data=Object(taggedTemplateLiteral.a)(["\n  ","\n"]);return styled_templateObject2=function _templateObject2(){return data},data}function styled_templateObject(){var data=Object(taggedTemplateLiteral.a)(["\n  margin-top: 0;\n  display: block;\n  margin-bottom: 1rem;\n  margin-block-end: 1em;\n  margin-inline-end: 0px;\n  margin-block-start: 1em;\n  margin-inline-start: 0px;\n"]);return styled_templateObject=function _templateObject(){return data},data}var MEDIA_QUERY_IS_MOBILE="@media only screen and (max-width: 768px)",_paragraphCSS=Object(styled_components_browser_esm.c)(styled_templateObject()),Content=styled_components_browser_esm.d.p(styled_templateObject2(),_paragraphCSS),Paragraph=styled_components_browser_esm.d.p(styled_templateObject3(),_paragraphCSS,"@media only screen and (min-width: 992px)"),Container=styled_components_browser_esm.d.div(styled_templateObject4(),MEDIA_QUERY_IS_MOBILE),SelectContainer=styled_components_browser_esm.d.div(_templateObject5(),"@media only screen and (max-width: 991px) and (min-width: 769px)",MEDIA_QUERY_IS_MOBILE),Hr=styled_components_browser_esm.d.hr(_templateObject6()),Columns=styled_components_browser_esm.d.div(_templateObject7(),"@media only screen and (min-width: 992px)"),Column=styled_components_browser_esm.d.div(_templateObject8(),MEDIA_QUERY_IS_MOBILE,(function(_ref){var widthPercent=_ref.widthPercent;return widthPercent&&"\n      flex: none;\n      width: ".concat(widthPercent,"%;\n    ")})),ListWrapper=styled_components_browser_esm.d.div(_templateObject9(),_paragraphCSS,"@media only screen and (min-width: 992px)"),List=styled_components_browser_esm.d.ul(_templateObject10(),MEDIA_QUERY_IS_MOBILE),Li=styled_components_browser_esm.d.li(_templateObject11()),TextHeader=styled_components_browser_esm.d.span(_templateObject12(),"@media only screen and (max-width: 525px)"),Title=styled_components_browser_esm.d.h2(_templateObject13()),SubTitle=styled_components_browser_esm.d.h4(_templateObject14()),Button=styled_components_browser_esm.d.button(_templateObject15(),MEDIA_QUERY_IS_MOBILE,"@media only screen and (max-width: 525px)"),Buttons=styled_components_browser_esm.d.div(_templateObject16()),styled_Label=styled_components_browser_esm.d.label(_templateObject17(),MEDIA_QUERY_IS_MOBILE),Checkboxes=styled_components_browser_esm.d.div(_templateObject18(),MEDIA_QUERY_IS_MOBILE),Card=styled_components_browser_esm.d.div(_templateObject19(),MEDIA_QUERY_IS_MOBILE),CardHeader=styled_components_browser_esm.d.div(_templateObject20(),MEDIA_QUERY_IS_MOBILE),CardBody=styled_components_browser_esm.d.div(_templateObject21(),MEDIA_QUERY_IS_MOBILE),OtherSpan=styled_components_browser_esm.d.span(_templateObject22()),_spinKeyframes=Object(styled_components_browser_esm.e)(_templateObject23()),_spinAnimationCss=Object(styled_components_browser_esm.c)(_templateObject24(),_spinKeyframes),ReactSvg=styled_components_browser_esm.d.svg(_templateObject25(),(function(_ref2){return!_ref2.isDisabled&&_spinAnimationCss})),ChevronDownSvg=styled_components_browser_esm.d.svg(_templateObject26(),(function(_ref3){return _ref3.menuOpen&&"transform: rotate(180deg);"})),OptionContainer=styled_components_browser_esm.d.div(_templateObject27()),OptionName=styled_components_browser_esm.d.span(_templateObject28()),markup=__webpack_require__(405),javascript=__webpack_require__(406);function CodeMarkup_templateObject3(){var data=Object(taggedTemplateLiteral.a)(["\n  width: 100%;\n  height: 100%;\n  overflow: auto;\n  border-radius: 6px;\n  min-height: 385px !important;\n  max-height: 385px !important;\n\n  pre {\n    font-size: 14px;\n    margin: 0 !important;\n    border: none !important;\n    box-shadow: none !important;\n    text-shadow: none !important;\n    padding: 1em !important;\n    background-color: #282c34 !important;\n\n    > code {\n      background: none !important;\n      text-shadow: none !important;\n      font-family: source-code-pro, Menlo, Monaco, Consolas, Courier New, monospace !important;\n      display: inherit;\n      color: #fff;\n\n      .block-comment,\n      .comment {\n        color: #ddd;\n        padding-right: 1.75em !important;\n      }\n\n      .boolean,\n      .function,\n      .number {\n        color: rgb(121, 182, 242);\n      }\n\n      .tag {\n        color: rgb(252, 146, 158);\n      }\n\n      .attr-name {\n        color: rgb(197, 165, 197);\n      }\n\n      .string,\n      .tag.attr-value {\n        color: rgb(141, 200, 145);\n      }\n\n      .token.punctuation,\n      .tag.punctuation,\n      .tag.attr-value.punctuation {\n        color: rgb(136, 198, 190);\n      }\n\n      .operator {\n        color: rgb(215, 222, 234);\n      }\n\n      "," {\n        font-size: 12px !important;\n\n        .block-comment,\n        .comment {\n          display: none !important;\n        }\n      }\n    }\n  }\n"]);return CodeMarkup_templateObject3=function _templateObject3(){return data},data}function CodeMarkup_templateObject2(){var data=Object(taggedTemplateLiteral.a)(["\n  line-height: 3;\n  color: #999;\n  padding: 0 .9rem;\n  font-weight: 700;\n  letter-spacing: 0.05em;\n  text-transform: uppercase;\n  background-color: #20232a;\n"]);return CodeMarkup_templateObject2=function _templateObject2(){return data},data}function CodeMarkup_templateObject(){var data=Object(taggedTemplateLiteral.a)(["\n  font-size: 1rem;\n  overflow: hidden;\n  border-radius: 6px;\n  margin: 1rem 1.5rem;\n  background-color: #282c34;\n\n  "," {\n    margin: 1rem 0;\n  }\n"]);return CodeMarkup_templateObject=function _templateObject(){return data},data}prism_light.a.registerLanguage("markup",markup.a),prism_light.a.registerLanguage("javascript",javascript.a);var CodeMarkupContainer=styled_components_browser_esm.d.div(CodeMarkup_templateObject(),MEDIA_QUERY_IS_MOBILE),Header=styled_components_browser_esm.d.div(CodeMarkup_templateObject2()),PreContainer=styled_components_browser_esm.d.div(CodeMarkup_templateObject3(),"@media only screen and (max-width: 525px)"),components_CodeMarkup=Object(react.memo)((function(_ref){var data=_ref.data,header=_ref.header,language=_ref.language,formatFn=_ref.formatFn;return Object(jsx_runtime.jsxs)(CodeMarkupContainer,{children:[Object(jsx_runtime.jsx)(Header,{children:header}),Object(jsx_runtime.jsx)(PreContainer,{children:Object(jsx_runtime.jsx)(prism_light.a,{wrapLines:!0,style:dark.a,showLineNumbers:!0,language:language,useInlineStyles:!1,children:formatFn?formatFn(data):data})})]})}));function PackageLink_templateObject(){var data=Object(taggedTemplateLiteral.a)(["\n  color: #149DF3;\n  cursor: pointer;\n  font-size: 1rem;\n  box-shadow: none;\n  font-weight: 600;\n  line-height: 1.2;\n  overflow: visible;\n  user-select: none;\n  padding: 0 .05rem;\n  text-align: center;\n  text-decoration: none;\n  display: inline-block;\n  background-color: transparent;\n  transition: box-shadow 0.2s ease-out;\n\n  :hover {\n    box-shadow: 0 1px 0 0 currentColor;\n  }\n"]);return PackageLink_templateObject=function _templateObject(){return data},data}var Link=styled_components_browser_esm.d.a(PackageLink_templateObject()),components_PackageLink=Object(react.memo)((function(_ref){var name=_ref.name,href=_ref.href;return Object(jsx_runtime.jsx)(Link,{href:href,target:"_blank","aria-label":name,rel:"noopener noreferrer",children:name})}));function OptionsCountButton_templateObject(){var data=Object(taggedTemplateLiteral.a)(["\n  width: 6.25rem;\n  transition: none;\n\n  ","\n\n  :focus {\n    color: #fff !important;\n    background-color: #149DF3 !important;\n  }\n"]);return OptionsCountButton_templateObject=function _templateObject(){return data},data}var _ThemeConfigMap,StyledButton=Object(styled_components_browser_esm.d)(Button)(OptionsCountButton_templateObject(),(function(_ref){return _ref.isActive&&"\n      color: #fff;\n      background-color: #149DF3;\n      :hover {\n        background-color: #0A93E9;\n      }\n    "})),components_OptionsCountButton=function OptionsCountButton(_ref2){var count=_ref2.count,optionsCount=_ref2.optionsCount,setOptionsCount=_ref2.setOptionsCount,isActive=count===optionsCount,onClick=isActive?void 0:function(){return setOptionsCount(count)};return Object(jsx_runtime.jsx)(StyledButton,{onClick:onClick,isActive:isActive,children:numberWithCommas(count)})},PACKAGE_OPTIONS=[{id:1,name:"react"},{id:2,name:"react-dom"},{id:3,name:"reactstrap"},{id:4,name:"react-scripts"},{id:5,name:"react-window"}],CITY_OPTIONS=[{id:1,city:"Boston",state:"MA"},{id:2,city:"Austin",state:"TX"},{id:3,city:"Denver",state:"CO"},{id:4,city:"Chicago",state:"IL"},{id:5,city:"Phoenix",state:"AZ"},{id:6,city:"Houston",state:"TX"},{id:7,city:"Orlando",state:"FL"},{id:8,city:"Portland",state:"OR"},{id:9,city:"Milwaukee",state:"WI"},{id:10,city:"Louisville",state:"KY"}],theme=__webpack_require__(137),object=__webpack_require__(246),_fadeInKeyframes="FADE_IN_KEYFRAMES 0.225s ease-in-out forwards",_themeAnimations={loader:{animation:"BOUNCE_KEYFRAMES 1.19s ease-in-out infinite"},menu:{animation:_fadeInKeyframes},multiValue:{animation:_fadeInKeyframes},icon:{clear:{animation:_fadeInKeyframes}}},ThemeEnum={DEFAULT:"Default",LARGE_TEXT:"Large text",DARK_COLORS:"Dark colors",ZERO_BORDER_RADIUS:"No border-radius"},ThemeConfigMap=(_ThemeConfigMap={},Object(defineProperty.a)(_ThemeConfigMap,ThemeEnum.DEFAULT,void 0),Object(defineProperty.a)(_ThemeConfigMap,ThemeEnum.DARK_COLORS,{color:{border:"#A8AEB4",primary:"#555555"},select:{css:"color: #000;"},control:{boxShadowColor:"rgba(85, 85, 85, 0.25)",focusedBorderColor:"rgba(85, 85, 85, 0.75)"},icon:{color:"#A6A6A6"},menu:{option:{selectedColor:"#fff",selectedBgColor:"#555555",focusedBgColor:"rgba(85, 85, 85, 0.225)"}}}),Object(defineProperty.a)(_ThemeConfigMap,ThemeEnum.LARGE_TEXT,{select:{css:"font-size: 1.25rem;"}}),Object(defineProperty.a)(_ThemeConfigMap,ThemeEnum.ZERO_BORDER_RADIUS,{control:{borderRadius:"0"},menu:{borderRadius:"0"}}),_ThemeConfigMap),THEME_OPTIONS=function createThemeOptions(ThemeEnum){return Object.keys(ThemeEnum).map((function(key){return{value:ThemeEnum[key],label:ThemeEnum[key]}}))}(ThemeEnum),THEME_DEFAULTS=Object(object.c)(theme.a,_themeAnimations),THEME_CONFIG={menu:{option:{selectedColor:"#515151",focusedBgColor:"#F5F5F5",selectedBgColor:"#F5F5F5"}}},dom=__webpack_require__(4),CLASS_NAME_HTML='<div class="'.concat(dom.r,'">\n  <div class="').concat(dom.i,'">\n    <div>\n      <div>Select option...</div>\n      <input\n        value=""\n        type="text"\n        class="').concat(dom.b,'"\n      />\n    </div>\n    <div>\n      <div>\n        <svg\n          aria-hidden="true"\n          viewBox="0 0 14 16"\n          class="').concat(dom.f,'"\n        >\n          <path\n            fillRule="evenodd"\n            d="M7.71 8.23l3.75 3.75-1.48..."\n          />\n        </svg>\n      </div>\n      <div />\n      <div>\n        <div\n          aria-hidden="true"\n          class="').concat(dom.d,'"\n        />\n      </div>\n    </div>\n  </div>\n  <div class="').concat(dom.l,'">\n    <div>\n      <div>\n        <div class="').concat(dom.n,'">\n          Option 1\n        </div>\n        <div class="').concat(dom.n," ").concat(dom.p,'">\n          Option 2\n        </div>\n        <div class="').concat(dom.n," ").concat(dom.q,'">\n          Option 3\n        </div>\n        <div class="').concat(dom.n," ").concat(dom.o,'">\n          Option 4\n        </div>\n      </div>\n    </div>\n  </div>\n</div>'),STYLED_COMPONENTS_PACKAGE={name:"styled-components",href:"https://www.styled-components.com"},REACT_WINDOW_PACKAGE={name:"react-window",href:"https://github.com/bvaughn/react-window"},TOAST_CONTAINER_PROPS={autoClose:2500,draggable:!1,newestOnTop:!0,position:"top-right"},index_stories_SingleSelect=(__webpack_exports__.default={parameters:Object(defineProperty.a)({storySource:{source:'\n      \n      // @ts-nocheck\n      // @ts-ignore\n      var __STORY__ = "import { useMemo, useRef, useState, useEffect, useCallback, Fragment, ReactNode } from \'react\';\\r\\nimport { toast } from \'react-toastify\';\\r\\nimport { SelectedOption } from \'../src/types\';\\r\\nimport { useUpdateEffect } from \'../src/hooks\';\\r\\nimport { useCallbackState } from \'./helpers/hooks\';\\r\\nimport { CityOption, Option, PackageOption } from \'./helpers/types\';\\r\\nimport { Select, MultiParams, MenuOption, SelectRef, FilterMatchEnum, Theme } from \'../src\';\\r\\nimport { Checkbox, CodeMarkup, PackageLink, OptionsCountButton } from \'./helpers/components\';\\r\\n\\r\\nimport {\\r\\n  mockHttpRequest,\\r\\n  getRandomInt,\\r\\n  createAsyncOptions,\\r\\n  createSelectOptions,\\r\\n  stringifyJavaScriptObj,\\r\\n  renderInfoToast\\r\\n} from \'./helpers/utils\';\\r\\n\\r\\nimport {\\r\\n  ThemeEnum,\\r\\n  ThemeConfigMap,\\r\\n  THEME_DEFAULTS,\\r\\n  THEME_OPTIONS,\\r\\n  THEME_CONFIG,\\r\\n  CITY_OPTIONS,\\r\\n  PACKAGE_OPTIONS,\\r\\n  CLASS_NAME_HTML,\\r\\n  REACT_WINDOW_PACKAGE,\\r\\n  TOAST_CONTAINER_PROPS,\\r\\n  STYLED_COMPONENTS_PACKAGE\\r\\n} from \'./helpers/constants\';\\r\\n\\r\\nimport {\\r\\n  OPTION_CLS,\\r\\n  OPTION_FOCUSED_CLS,\\r\\n  OPTION_DISABLED_CLS,\\r\\n  OPTION_SELECTED_CLS,\\r\\n  CARET_ICON_CLS,\\r\\n  CLEAR_ICON_CLS,\\r\\n  LOADING_DOTS_CLS,\\r\\n  AUTOSIZE_INPUT_CLS,\\r\\n  MENU_CONTAINER_CLS,\\r\\n  SELECT_CONTAINER_CLS,\\r\\n  CONTROL_CONTAINER_CLS,\\r\\n} from \'../src/constants/dom\';\\r\\n\\r\\nimport {\\r\\n  Button,\\r\\n  Buttons,\\r\\n  Hr,\\r\\n  Title,\\r\\n  SubTitle,\\r\\n  Label,\\r\\n  Columns,\\r\\n  Column,\\r\\n  Content,\\r\\n  Container,\\r\\n  List,\\r\\n  Li,\\r\\n  ListWrapper,\\r\\n  SelectContainer,\\r\\n  Paragraph,\\r\\n  TextHeader,\\r\\n  Checkboxes,\\r\\n  Card,\\r\\n  CardHeader,\\r\\n  CardBody,\\r\\n  OtherSpan,\\r\\n  OptionContainer,\\r\\n  OptionName,\\r\\n  ReactSvg,\\r\\n  ChevronDownSvg\\r\\n} from \'./helpers/styled\';\\r\\n\\r\\nexport default {\\r\\n  title: \'React Functional Select\'\\r\\n};\\r\\n\\r\\nexport const SingleSelect = () => {\\r\\n  const [isInvalid, setIsInvalid] = useCallbackState(false);\\r\\n  const [isLoading, setIsLoading] = useCallbackState(false);\\r\\n  const [isDisabled, setIsDisabled] = useCallbackState(false);\\r\\n  const [isClearable, setIsClearable] = useCallbackState(true);\\r\\n  const [isSearchable, setIsSearchable] = useCallbackState(true);\\r\\n\\r\\n  const getOptionValue = useCallback((option: CityOption): number => option.id, []);\\r\\n  const getOptionLabel = useCallback((option: CityOption): string => `${option.city}, ${option.state}`, []);\\r\\n\\r\\n  useEffect(() => {\\r\\n    isDisabled && setIsInvalid(false);\\r\\n  }, [isDisabled]);\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Single-select</Title>\\r\\n      <Hr />\\r\\n      <Paragraph>\\r\\n        In this story\'s source code, notice that the callback function\\r\\n        properties <code>getOptionValue</code> and <code>getOptionLabel</code> are\\r\\n        wrapped in a <code>useCallback</code>. While not required, <em> strongly prefer </em>\\r\\n        memoization of any callback function property whenever possible. This will boost\\r\\n        performance and reduce the amount of renders as these properties are referenced\\r\\n        in the dependency arrays of <code>useCallbacks</code>, <code>useEffects</code>,\\r\\n        and <code>useMemos</code>. When defined in a functional component, wrap in\\r\\n        a <code>useCallback</code>; when defined in a legacy class component, ensure proper\\r\\n        binding to <code>this</code>. Alternatively, if there is no dependency on any state,\\r\\n        you can opt to hoist functions outside of the component entirely.\\r\\n      </Paragraph>\\r\\n      <Paragraph>\\r\\n        The <code>options</code> property should also be memoized. Either consume\\r\\n        it directly from a state management store, or make sure it is stable by\\r\\n        avoiding inline or render-based mutations.\\r\\n      </Paragraph>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Checkboxes>\\r\\n            <Checkbox\\r\\n              label=\'Searchable\'\\r\\n              checked={isSearchable}\\r\\n              onCheck={setIsSearchable}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'Clearable\'\\r\\n              checked={isClearable}\\r\\n              onCheck={setIsClearable}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'Disabled\'\\r\\n              checked={isDisabled}\\r\\n              onCheck={setIsDisabled}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'Invalid\'\\r\\n              checked={isInvalid}\\r\\n              readOnly={isDisabled}\\r\\n              onCheck={setIsInvalid}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'Loading\'\\r\\n              checked={isLoading}\\r\\n              onCheck={setIsLoading}\\r\\n            />\\r\\n          </Checkboxes>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <SelectContainer>\\r\\n            <Select\\r\\n              isLoading={isLoading}\\r\\n              isInvalid={isInvalid}\\r\\n              options={CITY_OPTIONS}\\r\\n              isDisabled={isDisabled}\\r\\n              isClearable={isClearable}\\r\\n              isSearchable={isSearchable}\\r\\n              getOptionValue={getOptionValue}\\r\\n              getOptionLabel={getOptionLabel}\\r\\n            />\\r\\n          </SelectContainer>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport const MultiSelect = () => {\\r\\n  const [openMenuOnClick, setOpenMenuOnClick] = useCallbackState(true);\\r\\n  const [closeMenuOnSelect, setCloseMenuOnSelect] = useCallbackState(true);\\r\\n  const [blurInputOnSelect, setBlurInputOnSelect] = useCallbackState(false);\\r\\n  const [hideSelectedOptions, setHideSelectedOptions] = useCallbackState(true);\\r\\n  const [useRenderMultiOptions, setUseRenderMultiOptions] = useCallbackState(false);\\r\\n\\r\\n  const getOptionValue = useCallback((option: CityOption): number => option.id, []);\\r\\n  const getOptionLabel = useCallback((option: CityOption): string => `${option.city}, ${option.state}`, []);\\r\\n\\r\\n  // Example \\"renderMultiOptions\\" property that can be used to further customize labeling for multi-option scenarios\\r\\n  const renderMultiOptions = useCallback(\\r\\n    ({ selected, renderOptionLabel }: MultiParams): ReactNode => (\\r\\n      <Fragment>\\r\\n        {selected.length && renderOptionLabel(selected[0].data)}\\r\\n        {selected.length > 1 && (\\r\\n          <OtherSpan>\\r\\n            {`(+${selected.length - 1} ${selected.length === 2 ? \'other\' : \'others\'})`}\\r\\n          </OtherSpan>\\r\\n        )}\\r\\n      </Fragment>\\r\\n    ),\\r\\n    []\\r\\n  );\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Multi-select</Title>\\r\\n      <Hr />\\r\\n      <ListWrapper>\\r\\n        Add the <code>isMulti</code> property to allow for multiple selections.\\r\\n        While in multi-select mode, some properties are now applicable and\\r\\n        others become more pertinent.\\r\\n        <List>\\r\\n          <Li>\\r\\n            <TextHeader>hideSelectedOptions?: boolean</TextHeader> - Hide the\\r\\n            selected option from the menu. Default value is false, however, if\\r\\n            undefined and <code>isMulti === true</code>, then its value defaults\\r\\n            to true.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>closeMenuOnSelect?: boolean</TextHeader> - Close the\\r\\n            menu of options when the user selects an option. Default value is\\r\\n            false, however, it may be benefical to set this property to true for\\r\\n            convenience in multi-select scenarios.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>renderMultiOptions(params: MultiParams): ReactNode</TextHeader> -\\r\\n            Optional callback function that can be used to further customize the selection label\\r\\n            in multi-select scenarios. <code>params</code> is an object that contains\\r\\n            the <code>selected</code> and <code>renderOptionLabel</code> properties (array\\r\\n            of selected options and function used to render individual option labels, respectively).\\r\\n            When this function is defined, left and right arrow navigation of individual options is\\r\\n            disabled. When using this property, it may be be a good idea to set the\\r\\n            property <code>backspaceClearsValue</code> to <em>false</em> in order to avoid accidentally\\r\\n            clearing all selections when searching.\\r\\n          </Li>\\r\\n        </List>\\r\\n      </ListWrapper>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Checkboxes>\\r\\n            <Checkbox\\r\\n              label=\'closeMenuOnSelect\'\\r\\n              checked={closeMenuOnSelect}\\r\\n              onCheck={setCloseMenuOnSelect}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'hideSelectedOptions\'\\r\\n              checked={hideSelectedOptions}\\r\\n              onCheck={setHideSelectedOptions}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'blurInputOnSelect\'\\r\\n              checked={blurInputOnSelect}\\r\\n              onCheck={setBlurInputOnSelect}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'openMenuOnClick (click caret if false)\'\\r\\n              checked={openMenuOnClick}\\r\\n              onCheck={setOpenMenuOnClick}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'renderMultiOptions (custom renderer)\'\\r\\n              checked={useRenderMultiOptions}\\r\\n              onCheck={setUseRenderMultiOptions}\\r\\n            />\\r\\n          </Checkboxes>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <SelectContainer>\\r\\n            <Select\\r\\n              isMulti\\r\\n              isClearable\\r\\n              isSearchable\\r\\n              options={CITY_OPTIONS}\\r\\n              getOptionValue={getOptionValue}\\r\\n              getOptionLabel={getOptionLabel}\\r\\n              openMenuOnClick={openMenuOnClick}\\r\\n              blurInputOnSelect={blurInputOnSelect}\\r\\n              closeMenuOnSelect={closeMenuOnSelect}\\r\\n              hideSelectedOptions={hideSelectedOptions}\\r\\n              backspaceClearsValue={!useRenderMultiOptions}\\r\\n              renderMultiOptions={useRenderMultiOptions ? renderMultiOptions : undefined}\\r\\n            />\\r\\n          </SelectContainer>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport const Styling = () => {\\r\\n  const [themeConfig, setThemeConfig] = useState<Theme>();\\r\\n  const [selectedOption, setSelectedOption] = useCallbackState<SelectedOption | null>(null);\\r\\n  const menuItemSize = (selectedOption && selectedOption.value === ThemeEnum.LARGE_TEXT) ? 44 : 35;\\r\\n\\r\\n  const memoizedMarkupNode = useMemo<ReactNode>(() => (\\r\\n    <CodeMarkup\\r\\n      language=\'markup\'\\r\\n      header=\'Class Markup\'\\r\\n      data={CLASS_NAME_HTML}\\r\\n    />\\r\\n  ), []);\\r\\n\\r\\n  useEffect(() => {\\r\\n    if (selectedOption) {\\r\\n      const { value } = selectedOption;\\r\\n      setThemeConfig(ThemeConfigMap[value]);\\r\\n    }\\r\\n  }, [selectedOption]);\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Styling</Title>\\r\\n      <Hr />\\r\\n      <SubTitle>Theming</SubTitle>\\r\\n      <Columns>\\r\\n        <Column widthPercent={40}>\\r\\n          <Content>\\r\\n            react-functional-select uses <PackageLink {...STYLED_COMPONENTS_PACKAGE} /> to\\r\\n            handle its styling. The root node is wrapped in\\r\\n            styled-component\'s <code>ThemeProvider</code> wrapper component which gives all\\r\\n            child styled-components access to the provided theme via React\'s context API.\\r\\n            To override react-functional-select\'s default theme, pass an object to\\r\\n            the <code>themeConfig</code> property - any matching properties will replace\\r\\n            those in the default theme.\\r\\n          </Content>\\r\\n          <Content>\\r\\n            Starting in <strong>v2.0.0</strong>, some of the nested objects in\\r\\n            the <code>themeConfig</code> object contain a <code>css</code> property\\r\\n            of type <code>string | FlattenSimpleInterpolation | undefined</code> (default value\\r\\n            is undefined). This property can be used to pass raw CSS styles as a string or wrapped\\r\\n            in <PackageLink {...STYLED_COMPONENTS_PACKAGE} /> exported <code>css</code> function.\\r\\n            Those objects are: select, control, icon, menu, noOptions, multiValue, and input.\\r\\n          </Content>\\r\\n          <Content>\\r\\n            Starting in <strong>v2.7.0</strong>, the control object in <code>themeConfig</code> has\\r\\n            the property <code>focusedCss</code> - which is similar to the <code>css</code> property,\\r\\n            except that it is only applied when the select control is focused (and removed when blurred).\\r\\n          </Content>\\r\\n        </Column>\\r\\n        <Column widthPercent={60}>\\r\\n          <CodeMarkup\\r\\n            language=\'javascript\'\\r\\n            data={THEME_DEFAULTS}\\r\\n            header=\'Theme Defaults\'\\r\\n            formatFn={stringifyJavaScriptObj}\\r\\n          />\\r\\n        </Column>\\r\\n      </Columns>\\r\\n      <SubTitle>Using Classes</SubTitle>\\r\\n      <Columns>\\r\\n        <Column widthPercent={40}>\\r\\n          <Content>\\r\\n            If you want to style the component using CSS classes, set the <code>addClassNames</code> prop\\r\\n            to true and it will then generate <code>className</code> attributes for that specific instance\\r\\n            of the component. These are the classes that are available:\\r\\n          </Content>\\r\\n          <ListWrapper className=\'is-class-list\'>\\r\\n            <List>\\r\\n              <Li>{SELECT_CONTAINER_CLS}</Li>\\r\\n              <Li>{CONTROL_CONTAINER_CLS}</Li>\\r\\n              <Li>{MENU_CONTAINER_CLS}</Li>\\r\\n              <Li>{AUTOSIZE_INPUT_CLS}</Li>\\r\\n              <Li>{CARET_ICON_CLS}</Li>\\r\\n              <Li>{CLEAR_ICON_CLS}</Li>\\r\\n              <Li>{LOADING_DOTS_CLS}</Li>\\r\\n              <Li>{`${OPTION_CLS}, ${OPTION_FOCUSED_CLS}, ${OPTION_SELECTED_CLS}, ${OPTION_DISABLED_CLS}`}</Li>\\r\\n            </List>\\r\\n          </ListWrapper>\\r\\n        </Column>\\r\\n        <Column widthPercent={60}>{memoizedMarkupNode}</Column>\\r\\n      </Columns>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Label>Try selecting different themes</Label>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <Columns>\\r\\n            <Column widthPercent={40}>\\r\\n              <div style={{ marginTop: \'1rem\' }}>\\r\\n                <Select\\r\\n                  isClearable={false}\\r\\n                  isSearchable={false}\\r\\n                  options={THEME_OPTIONS}\\r\\n                  themeConfig={themeConfig}\\r\\n                  menuItemSize={menuItemSize}\\r\\n                  initialValue={THEME_OPTIONS[0]}\\r\\n                  onOptionChange={setSelectedOption}\\r\\n                />\\r\\n              </div>\\r\\n            </Column>\\r\\n            <Column widthPercent={60}>\\r\\n              <CodeMarkup\\r\\n                data={themeConfig}\\r\\n                language=\'javascript\'\\r\\n                header=\'theme-config\'\\r\\n                formatFn={stringifyJavaScriptObj}\\r\\n              />\\r\\n            </Column>\\r\\n          </Columns>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport const Events = () => {\\r\\n  const options = useMemo<Option[]>(() => createSelectOptions(5), []);\\r\\n\\r\\n  const [addOnKeyDown, setAddOnKeyDown] = useCallbackState(false);\\r\\n  const [addOnMenuOpen, setAddOnMenuOpen] = useCallbackState(true);\\r\\n  const [addOnMenuClose, setAddOnMenuClose] = useCallbackState(false);\\r\\n  const [addOnInputBlur, setAddOnInputBlur] = useCallbackState(false);\\r\\n  const [addOnInputFocus, setAddOnInputFocus] = useCallbackState(false);\\r\\n  const [addOnOptionChange, setAddOnOptionChange] = useCallbackState(true);\\r\\n\\r\\n  const onOptionChange = useCallback((option: Option | null): void => {\\r\\n    const optionJsonStr = JSON.stringify(option || {}).replace(/\\"/g, \\"\'\\");\\r\\n    renderInfoToast(`Selected Option: ${optionJsonStr}`);\\r\\n  }, []);\\r\\n\\r\\n  const onMenuOpen = useCallback((): void => renderInfoToast(\'Menu opened!\'), []);\\r\\n  const onMenuClose = useCallback((): void => renderInfoToast(\'Menu closed!\'), []);\\r\\n  const onInputBlur = useCallback((): void => renderInfoToast(\'Control blurred!\'), []);\\r\\n  const onInputFocus = useCallback((): void => renderInfoToast(\'Control focused!\'), []);\\r\\n  const onKeyDown = useCallback((): void => renderInfoToast(\'keydown event executed!\'), []);\\r\\n\\r\\n  // Configure reat-toastify onMount and cleanup active toasts on beforeDismount\\r\\n  useEffect(() => {\\r\\n    toast.configure(TOAST_CONTAINER_PROPS);\\r\\n\\r\\n    return () => {\\r\\n      toast.dismiss();\\r\\n    };\\r\\n  }, []);\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Events</Title>\\r\\n      <Hr />\\r\\n      <ListWrapper>\\r\\n        There are various callback function properties that are executed following\\r\\n        their associated events:\\r\\n        <List>\\r\\n          <Li>\\r\\n            <TextHeader>onOptionChange(data: any): void</TextHeader> -\\r\\n            executed after an option is selected or removed\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>onMenuOpen(...args: any[]): void</TextHeader> -\\r\\n            executed after the menu is opened\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>onMenuClose(...args: any[]): void</TextHeader> -\\r\\n            executed after the menu is closed\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>onInputChange(value: string): void</TextHeader> -\\r\\n            executed after the input control\'s value changes\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>onInputBlur(e: FocusEvent&lt;HTMLInputElement&gt;): void</TextHeader> -\\r\\n            executed after the input control is blurred\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>onInputFocus(e: FocusEvent&lt;HTMLInputElement&gt;): void</TextHeader> -\\r\\n            executed after the input control is focused\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>onKeyDown(e: KeyboardEvent&lt;HTMLDivElement&gt;, input?: string, focusedOption?: FocusedOption): void</TextHeader> -\\r\\n            executed after the onKeyDown event\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>onSearchChange(value: string): void</TextHeader> -\\r\\n            executed after the input value is persisted to state; this value also evaluates\\r\\n            the <code>inputDelay</code> property for debouncing - this callback is really only\\r\\n            useful when <code>inputDelay</code> is defined, and if not, it probably makes more\\r\\n            sense to use the <code>onInputChange</code> callback\\r\\n          </Li>\\r\\n        </List>\\r\\n      </ListWrapper>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Label>Events trigger a toast notification</Label>\\r\\n          <Checkboxes>\\r\\n            <Checkbox\\r\\n              label=\'onOptionChange\'\\r\\n              checked={addOnOptionChange}\\r\\n              onCheck={setAddOnOptionChange}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'onMenuOpen\'\\r\\n              checked={addOnMenuOpen}\\r\\n              onCheck={setAddOnMenuOpen}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'onMenuClose\'\\r\\n              checked={addOnMenuClose}\\r\\n              onCheck={setAddOnMenuClose}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'onInputBlur\'\\r\\n              checked={addOnInputBlur}\\r\\n              onCheck={setAddOnInputBlur}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'onInputFocus\'\\r\\n              checked={addOnInputFocus}\\r\\n              onCheck={setAddOnInputFocus}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'onKeyDown\'\\r\\n              checked={addOnKeyDown}\\r\\n              onCheck={setAddOnKeyDown}\\r\\n            />\\r\\n          </Checkboxes>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <SelectContainer>\\r\\n            <Select\\r\\n              options={options}\\r\\n              onKeyDown={addOnKeyDown ? onKeyDown : undefined}\\r\\n              onMenuOpen={addOnMenuOpen ? onMenuOpen : undefined}\\r\\n              onMenuClose={addOnMenuClose ? onMenuClose : undefined}\\r\\n              onInputBlur={addOnInputBlur ? onInputBlur : undefined}\\r\\n              onInputFocus={addOnInputFocus ? onInputFocus : undefined}\\r\\n              onOptionChange={addOnOptionChange ? onOptionChange : undefined}\\r\\n            />\\r\\n          </SelectContainer>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport const Methods = () => {\\r\\n  const selectRef = useRef<SelectRef | null>(null);\\r\\n  const options = useMemo<Option[]>(() => createSelectOptions(5), []);\\r\\n\\r\\n  const blurSelect = (): void => {\\r\\n    selectRef.current && selectRef.current.blur();\\r\\n  };\\r\\n\\r\\n  const focusSelect = (): void => {\\r\\n    selectRef.current && selectRef.current.focus();\\r\\n  };\\r\\n\\r\\n  const clearValue = (): void => {\\r\\n    selectRef.current && selectRef.current.clearValue();\\r\\n  };\\r\\n\\r\\n  const toggleMenuOpen = (): void => {\\r\\n    selectRef.current && selectRef.current.toggleMenu(true);\\r\\n  };\\r\\n\\r\\n  const updateSelectedOption = (): void => {\\r\\n    selectRef.current && selectRef.current.setValue(options[0]);\\r\\n  };\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Methods</Title>\\r\\n      <Hr />\\r\\n      <ListWrapper>\\r\\n        Five public methods are exposed to wrapping components and are\\r\\n        accessible via a forwarded <code>ref</code>.\\r\\n        <List>\\r\\n          <Li>\\r\\n            <TextHeader>blur(): void</TextHeader> - blur the control\\r\\n            programatically\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>focus(): void</TextHeader> - focus the control\\r\\n            programatically\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>toggleMenu(state?: boolean): void</TextHeader> -\\r\\n            toggle the menu programatically\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>clearValue(): void</TextHeader> - clear the current\\r\\n            value programatically <em>(if an option is selected)</em>\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>setValue(option?: any): void</TextHeader> - set the\\r\\n            value programatically <em>(option will be validated)</em>\\r\\n          </Li>\\r\\n        </List>\\r\\n      </ListWrapper>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Label>Methods</Label>\\r\\n          <Buttons>\\r\\n            <Button onClick={focusSelect}>Focus</Button>\\r\\n            <Button onClick={blurSelect}>Blur</Button>\\r\\n            <Button onClick={toggleMenuOpen}>Open Menu</Button>\\r\\n            <Button onClick={clearValue}>Clear Value</Button>\\r\\n            <Button onClick={updateSelectedOption}>Set Value (1st Option)</Button>\\r\\n          </Buttons>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <SelectContainer>\\r\\n            <Select\\r\\n              ref={selectRef}\\r\\n              options={options}\\r\\n              initialValue={options[0]}\\r\\n            />\\r\\n          </SelectContainer>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport const Filtering = () => {\\r\\n  const [filterIgnoreCase, setFilterIgnoreCase] = useCallbackState(true);\\r\\n  const [useCustomFilterFunc, setUseCustomFilterFunc] = useCallbackState(false);\\r\\n  const [filterIgnoreAccents, setFilterIgnoreAccents] = useCallbackState(false);\\r\\n  const [filterMatchFromStart, setFilterMatchFromStart] = useCallbackState(false);\\r\\n\\r\\n  const getOptionValue = useCallback((option: CityOption): number => option.id, []);\\r\\n  const getOptionLabel = useCallback((option: CityOption): string => `${option.city}, ${option.state}`, []);\\r\\n  const getFilterOptionString = useCallback((menuOption: MenuOption): string => menuOption.data.state, []);\\r\\n\\r\\n  const options = useMemo<CityOption[]>(() => [...CITY_OPTIONS, { id: 11, city: \'So Paulo\', state: \'BR\' }], []);\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Filter Customization</Title>\\r\\n      <Hr />\\r\\n      <ListWrapper>\\r\\n        The default filtering functionality can be customized via the following properties:\\r\\n        <List>\\r\\n          <Li>\\r\\n            <TextHeader>filterIgnoreCase?: boolean</TextHeader> - Filter ignores\\r\\n            case when matching strings. Default value is <code>true</code>.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>filterIgnoreAccents?: boolean</TextHeader> - Filter\\r\\n            ignores accents when matching strings. Default value is <code>false</code>.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>filterMatchFrom?: \'any\' | \'start\'</TextHeader> -\\r\\n            Position in source string to perform match. Default value is <code>\'any\'</code>.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>getFilterOptionString(option: MenuOption): string</TextHeader> -\\r\\n            When defined will take each option and generate a string used in\\r\\n            the filtering process. By default, the stringified version of what is\\r\\n            generated by <code>getOptionLabel</code>, if definded, or the option\'s label\\r\\n            as a fallback. The <code>MenuOption</code> typed parameter\\r\\n            that <code>getFilterOptionString</code> accepts contains a <code>data</code> property\\r\\n            that represents the objects that comprise your <code>options</code> property.\\r\\n          </Li>\\r\\n        </List>\\r\\n      </ListWrapper>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Checkboxes>\\r\\n            <Checkbox\\r\\n              label=\'Ignore Case\'\\r\\n              checked={filterIgnoreCase}\\r\\n              onCheck={setFilterIgnoreCase}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'Ignore Accents\'\\r\\n              checked={filterIgnoreAccents}\\r\\n              onCheck={setFilterIgnoreAccents}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'Match from the start\'\\r\\n              checked={filterMatchFromStart}\\r\\n              onCheck={setFilterMatchFromStart}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'Use custom filter function (by state only)\'\\r\\n              checked={useCustomFilterFunc}\\r\\n              onCheck={setUseCustomFilterFunc}\\r\\n            />\\r\\n          </Checkboxes>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <SelectContainer>\\r\\n            <Select\\r\\n              isClearable\\r\\n              options={options}\\r\\n              getOptionValue={getOptionValue}\\r\\n              getOptionLabel={getOptionLabel}\\r\\n              filterIgnoreCase={filterIgnoreCase}\\r\\n              filterIgnoreAccents={filterIgnoreAccents}\\r\\n              getFilterOptionString={useCustomFilterFunc ? getFilterOptionString : undefined}\\r\\n              filterMatchFrom={filterMatchFromStart ? FilterMatchEnum.START : FilterMatchEnum.ANY}\\r\\n            />\\r\\n          </SelectContainer>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport const Windowing = () => {\\r\\n  const optionCountList: number[] = [100, 1000, 5000, 25000, 50000];\\r\\n\\r\\n  const selectRef = useRef<SelectRef | null>(null);\\r\\n  const [options, setOptions] = useState<Option[]>([]);\\r\\n  const [optionsCount, setOptionsCount] = useState<number>(optionCountList[0]);\\r\\n\\r\\n  useUpdateEffect(() => {\\r\\n    selectRef.current && selectRef.current.clearValue();\\r\\n  }, [options]);\\r\\n\\r\\n  useEffect(() => {\\r\\n    const nextSelectOptions = createSelectOptions(optionsCount);\\r\\n    setOptions(nextSelectOptions);\\r\\n  }, [optionsCount]);\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Integrated Windowing</Title>\\r\\n      <Hr />\\r\\n      <ListWrapper>\\r\\n        Option data is \'windowed\' using the{\' \'}\\r\\n        <PackageLink {...REACT_WINDOW_PACKAGE} /> package. Aside from the\\r\\n        obvious benefits provided by only rendering a small subset of your\\r\\n        enumerable data (rather than bloating the DOM with an excessive amount\\r\\n        of nodes), \'windowing\' can also assist with:\\r\\n        <List>\\r\\n          <Li>\\r\\n            <strong>Efficient memory allocation</strong>. \'Windowing\' naturally\\r\\n            lends itself to the dynamic generation of attributes/values as each\\r\\n            object comes into your renderer\'s scope (as opposed to allocating\\r\\n            this data upfront for each object in your list). This way you can\\r\\n            perform this work just when you absolutely need to and then can\\r\\n            immediately release it for the GC to cleanup. As an example I am\\r\\n            generating the <code>onClick</code>, <code>id</code>, and{\' \'}\\r\\n            <code>className</code> attributes for each <code>menuOption</code>{\' \'}\\r\\n            as they get passed to the <code>&lt;Option /&gt;</code> renderer\\r\\n            component.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <strong>Functional architecture</strong>. The flexibility provided\\r\\n            through only having to manage subsets of your list allows for a more\\r\\n            dynamic application. By breaking your code out into smaller, \'pure\'\\r\\n            child components, you can write code that scales well and becomes\\r\\n            open to performance optimizations - most notably, memoization.\\r\\n            Simple components that rely on the props passed to it (rather than\\r\\n            its own managed state) to generate its JSX are likely candidates for\\r\\n            memoization (testing &amp; debugging becomes much easier as well).\\r\\n          </Li>\\r\\n        </List>\\r\\n        <em>Note: </em>The only time any noticeable performance degradation will\\r\\n        be observed is during search input updates when the <code>options</code>{\' \'}\\r\\n        count reaches the high tens of thousands. To work around this, the{\' \'}\\r\\n        <code>inputDelay</code> (number in milliseconds) can be set to debounce\\r\\n        the input value. That way, the <code>menuOptions</code> will not be\\r\\n        recalculated on every keystroke.\\r\\n      </ListWrapper>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Label>Options Count</Label>\\r\\n          <Buttons>\\r\\n            {optionCountList.map((count) => (\\r\\n              <OptionsCountButton\\r\\n                key={count}\\r\\n                count={count}\\r\\n                optionsCount={optionsCount}\\r\\n                setOptionsCount={setOptionsCount}\\r\\n              />\\r\\n            ))}\\r\\n          </Buttons>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <SelectContainer>\\r\\n            <Select ref={selectRef} options={options} />\\r\\n          </SelectContainer>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport const Advanced = () => {\\r\\n  const getOptionValue = useCallback((option: PackageOption): number => option.id, []);\\r\\n  const getIsOptionDisabled = useCallback((option: PackageOption): boolean => (option.name === PACKAGE_OPTIONS[3].name), []);\\r\\n\\r\\n  const renderOptionLabel = useCallback(\\r\\n    (option: PackageOption): ReactNode => (\\r\\n      <OptionContainer>\\r\\n        <ReactSvg\\r\\n          aria-hidden=\'true\'\\r\\n          viewBox=\'0 0 841.9 595.3\'\\r\\n          isDisabled={getIsOptionDisabled(option)}\\r\\n        >\\r\\n          <path d=\\"M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z\\" />\\r\\n          <circle cx=\\"420.9\\" cy=\\"296.5\\" r=\\"45.7\\" />\\r\\n        </ReactSvg>\\r\\n        <OptionName>{option.name}</OptionName>\\r\\n      </OptionContainer>\\r\\n    ),\\r\\n    [getIsOptionDisabled]\\r\\n  );\\r\\n\\r\\n  const customCaretIcon = useCallback(\\r\\n    ({ menuOpen }): ReactNode => (\\r\\n      <ChevronDownSvg menuOpen={menuOpen} aria-hidden=\'true\' viewBox=\'0 0 448 512\'>\\r\\n        <path d=\'M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z\' />\\r\\n      </ChevronDownSvg>\\r\\n    ),\\r\\n    []\\r\\n  );\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Advanced Customization</Title>\\r\\n      <Hr />\\r\\n      <ListWrapper>\\r\\n        Implementation using a couple of the more specialized properties.\\r\\n        <List>\\r\\n          <Li>\\r\\n            <TextHeader>renderOptionLabel(option: any): React.ReactNode</TextHeader> - Callback\\r\\n            function with a return type of <code>ReactNode</code>. Use this property in cases\\r\\n            where the standard <code>getOptionLabel</code> property won\'t meet your needs (for\\r\\n            instance, you want to render each option\'s label using custom JSX). More complex\\r\\n            option labels will likely equate to longer render durations - this can translate\\r\\n            into a flash of empty space when a user first starts scrolling. In order to prevent\\r\\n            this, the <code>menuOverscanCount</code> property can be increased to render additional\\r\\n            rows outside of the visible area. The default value for this property is 1 and it is\\r\\n            important to note that increasing this value can negatively impact performance.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>getIsOptionDisabled(option: any): boolean</TextHeader> - Callback\\r\\n            function with a return type of <code>Boolean</code>. When it evaluates to a value of\\r\\n            true, that option iteration will be rendered <em>disabled</em>. As an alternative, you\\r\\n            can also pass a property of <code>isDisabled</code> with each option. Use of these two\\r\\n            options - they cannot both be specified.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>caretIcon: ReactNode | (...args: any[]) =&gt; ReactNode</TextHeader> - A custom\\r\\n            node or a function that returns a node can used for the <code>caretIcon</code> property.\\r\\n            When using a function, an object containing stateful data is forwarded and can be used to style\\r\\n            your custom node accordingly. The state is <code>{\'{ menuOpen, isLoading, isInvalid, isDisabled }\'}</code> of\\r\\n            type <code>Record&lt;string, boolean&gt;</code>. The <code>clearIcon</code> property has an identical definition.\\r\\n          </Li>\\r\\n        </List>\\r\\n      </ListWrapper>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Label>JSX labels, custom caret icon, and disabled option</Label>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <SelectContainer>\\r\\n            <Select\\r\\n              isSearchable={false}\\r\\n              options={PACKAGE_OPTIONS}\\r\\n              themeConfig={THEME_CONFIG}\\r\\n              caretIcon={customCaretIcon}\\r\\n              getOptionValue={getOptionValue}\\r\\n              renderOptionLabel={renderOptionLabel}\\r\\n              getIsOptionDisabled={getIsOptionDisabled}\\r\\n            />\\r\\n          </SelectContainer>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport const Async = () => {\\r\\n  const [isLoading, setIsLoading] = useState<boolean>(false);\\r\\n  const [options, setOptions] = useState<Option[]>(() => createAsyncOptions(5, \'Initial\'));\\r\\n\\r\\n  const onInputChange = useCallback((): void => setIsLoading(true), []);\\r\\n\\r\\n  const onSearchChange = useCallback((value?: string): void => {\\r\\n    mockHttpRequest()\\r\\n      .then(() => {\\r\\n        const nextOptions = createAsyncOptions(\\r\\n          getRandomInt(1, 5),\\r\\n          `Search text: ${value || \'Initial\'}`\\r\\n        );\\r\\n\\r\\n        setOptions(nextOptions);\\r\\n      })\\r\\n      .catch((err) => console.error(err))\\r\\n      .then(() => setIsLoading(false));\\r\\n  }, []);\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Async Mode</Title>\\r\\n      <Hr />\\r\\n      <ListWrapper>\\r\\n        Add the <code>async</code> property to enable async mode. There is one key\\r\\n        difference in core functionality with async mode - changes to search input\\r\\n        value will not cause the <code>useMenuOptions</code> effect to run. The rest\\r\\n        of hooking into async mode is achieved using some combination of the properties\\r\\n        found below. <em>Properties onInputChange and onSearchChange should be memoized.</em>\\r\\n        <List>\\r\\n          <Li>\\r\\n            <TextHeader>onInputChange(value: string): void</TextHeader> -\\r\\n            callback executed directly following the input control\'s <code>onChange</code> event.\\r\\n            This callback is not debounced, so it fires immediately. This is a good\\r\\n            place to set a stateful loading property in your parent component that is mapped to\\r\\n            react-functional-select\'s <code>isLoading</code> property.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>onSearchChange(value: string): void</TextHeader> -\\r\\n            callback executed following component state updates for\\r\\n            the <code>debouncedInputValue</code>. The debounce is set using\\r\\n            the <code>inputDelay</code> property. This callback is a good place for your\\r\\n            http fetch request and post-request logic (i.e. setting isLoading false).\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>inputDelay?: number</TextHeader> - As mentioned above, this can be\\r\\n            set to a positive integer in order to debounce updates to the search input value\\r\\n            following input change events. This property directly maps to the <code>delay</code> in\\r\\n            milliconds passed to the <code>setTimeout</code> method.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>isLoading?: boolean</TextHeader> - When true, a loading animation will\\r\\n            appear in the far-right of the control and take the place of the clear icon (if shown).\\r\\n            Additionally, it will hide options in the menu and instead, display a loading message.\\r\\n            The loading message text defaults to \'Loading...\', but can be overriden via\\r\\n            the <code>loadingMsg</code> property.\\r\\n          </Li>\\r\\n        </List>\\r\\n      </ListWrapper>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Label>Search debounced 500ms and mock HTTP call resolves after 500ms</Label>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <SelectContainer>\\r\\n            <Select\\r\\n              async\\r\\n              isClearable\\r\\n              inputDelay={500}\\r\\n              options={options}\\r\\n              isLoading={isLoading}\\r\\n              onInputChange={onInputChange}\\r\\n              onSearchChange={onSearchChange}\\r\\n            />\\r\\n          </SelectContainer>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};";\n      // @ts-ignore\n      var __LOCATIONS_MAP__ = {"SingleSelect":{"startLoc":{"col":28,"line":79},"endLoc":{"col":1,"line":164},"startBody":{"col":28,"line":79},"endBody":{"col":1,"line":164}},"MultiSelect":{"startLoc":{"col":27,"line":166},"endLoc":{"col":1,"line":278},"startBody":{"col":27,"line":166},"endBody":{"col":1,"line":278}},"Styling":{"startLoc":{"col":23,"line":280},"endLoc":{"col":1,"line":396},"startBody":{"col":23,"line":280},"endBody":{"col":1,"line":396}},"Events":{"startLoc":{"col":22,"line":398},"endLoc":{"col":1,"line":527},"startBody":{"col":22,"line":398},"endBody":{"col":1,"line":527}},"Methods":{"startLoc":{"col":23,"line":529},"endLoc":{"col":1,"line":608},"startBody":{"col":23,"line":529},"endBody":{"col":1,"line":608}},"Filtering":{"startLoc":{"col":25,"line":610},"endLoc":{"col":1,"line":696},"startBody":{"col":25,"line":610},"endBody":{"col":1,"line":696}},"Windowing":{"startLoc":{"col":25,"line":698},"endLoc":{"col":1,"line":779},"startBody":{"col":25,"line":698},"endBody":{"col":1,"line":779}},"Advanced":{"startLoc":{"col":24,"line":781},"endLoc":{"col":1,"line":867},"startBody":{"col":24,"line":781},"endBody":{"col":1,"line":867}},"Async":{"startLoc":{"col":21,"line":869},"endLoc":{"col":1,"line":951},"startBody":{"col":21,"line":869},"endBody":{"col":1,"line":951}}};\nimport { useMemo, useRef, useState, useEffect, useCallback, Fragment, ReactNode } from \'react\';\r\nimport { toast } from \'react-toastify\';\r\nimport { SelectedOption } from \'../src/types\';\r\nimport { useUpdateEffect } from \'../src/hooks\';\r\nimport { useCallbackState } from \'./helpers/hooks\';\r\nimport { CityOption, Option, PackageOption } from \'./helpers/types\';\r\nimport { Select, MultiParams, MenuOption, SelectRef, FilterMatchEnum, Theme } from \'../src\';\r\nimport { Checkbox, CodeMarkup, PackageLink, OptionsCountButton } from \'./helpers/components\';\r\n\r\nimport {\r\n  mockHttpRequest,\r\n  getRandomInt,\r\n  createAsyncOptions,\r\n  createSelectOptions,\r\n  stringifyJavaScriptObj,\r\n  renderInfoToast\r\n} from \'./helpers/utils\';\r\n\r\nimport {\r\n  ThemeEnum,\r\n  ThemeConfigMap,\r\n  THEME_DEFAULTS,\r\n  THEME_OPTIONS,\r\n  THEME_CONFIG,\r\n  CITY_OPTIONS,\r\n  PACKAGE_OPTIONS,\r\n  CLASS_NAME_HTML,\r\n  REACT_WINDOW_PACKAGE,\r\n  TOAST_CONTAINER_PROPS,\r\n  STYLED_COMPONENTS_PACKAGE\r\n} from \'./helpers/constants\';\r\n\r\nimport {\r\n  OPTION_CLS,\r\n  OPTION_FOCUSED_CLS,\r\n  OPTION_DISABLED_CLS,\r\n  OPTION_SELECTED_CLS,\r\n  CARET_ICON_CLS,\r\n  CLEAR_ICON_CLS,\r\n  LOADING_DOTS_CLS,\r\n  AUTOSIZE_INPUT_CLS,\r\n  MENU_CONTAINER_CLS,\r\n  SELECT_CONTAINER_CLS,\r\n  CONTROL_CONTAINER_CLS,\r\n} from \'../src/constants/dom\';\r\n\r\nimport {\r\n  Button,\r\n  Buttons,\r\n  Hr,\r\n  Title,\r\n  SubTitle,\r\n  Label,\r\n  Columns,\r\n  Column,\r\n  Content,\r\n  Container,\r\n  List,\r\n  Li,\r\n  ListWrapper,\r\n  SelectContainer,\r\n  Paragraph,\r\n  TextHeader,\r\n  Checkboxes,\r\n  Card,\r\n  CardHeader,\r\n  CardBody,\r\n  OtherSpan,\r\n  OptionContainer,\r\n  OptionName,\r\n  ReactSvg,\r\n  ChevronDownSvg\r\n} from \'./helpers/styled\';\r\n\r\nexport default {parameters: {"storySource":{"source":"import { useMemo, useRef, useState, useEffect, useCallback, Fragment, ReactNode } from \'react\';\\r\\nimport { toast } from \'react-toastify\';\\r\\nimport { SelectedOption } from \'../src/types\';\\r\\nimport { useUpdateEffect } from \'../src/hooks\';\\r\\nimport { useCallbackState } from \'./helpers/hooks\';\\r\\nimport { CityOption, Option, PackageOption } from \'./helpers/types\';\\r\\nimport { Select, MultiParams, MenuOption, SelectRef, FilterMatchEnum, Theme } from \'../src\';\\r\\nimport { Checkbox, CodeMarkup, PackageLink, OptionsCountButton } from \'./helpers/components\';\\r\\n\\r\\nimport {\\r\\n  mockHttpRequest,\\r\\n  getRandomInt,\\r\\n  createAsyncOptions,\\r\\n  createSelectOptions,\\r\\n  stringifyJavaScriptObj,\\r\\n  renderInfoToast\\r\\n} from \'./helpers/utils\';\\r\\n\\r\\nimport {\\r\\n  ThemeEnum,\\r\\n  ThemeConfigMap,\\r\\n  THEME_DEFAULTS,\\r\\n  THEME_OPTIONS,\\r\\n  THEME_CONFIG,\\r\\n  CITY_OPTIONS,\\r\\n  PACKAGE_OPTIONS,\\r\\n  CLASS_NAME_HTML,\\r\\n  REACT_WINDOW_PACKAGE,\\r\\n  TOAST_CONTAINER_PROPS,\\r\\n  STYLED_COMPONENTS_PACKAGE\\r\\n} from \'./helpers/constants\';\\r\\n\\r\\nimport {\\r\\n  OPTION_CLS,\\r\\n  OPTION_FOCUSED_CLS,\\r\\n  OPTION_DISABLED_CLS,\\r\\n  OPTION_SELECTED_CLS,\\r\\n  CARET_ICON_CLS,\\r\\n  CLEAR_ICON_CLS,\\r\\n  LOADING_DOTS_CLS,\\r\\n  AUTOSIZE_INPUT_CLS,\\r\\n  MENU_CONTAINER_CLS,\\r\\n  SELECT_CONTAINER_CLS,\\r\\n  CONTROL_CONTAINER_CLS,\\r\\n} from \'../src/constants/dom\';\\r\\n\\r\\nimport {\\r\\n  Button,\\r\\n  Buttons,\\r\\n  Hr,\\r\\n  Title,\\r\\n  SubTitle,\\r\\n  Label,\\r\\n  Columns,\\r\\n  Column,\\r\\n  Content,\\r\\n  Container,\\r\\n  List,\\r\\n  Li,\\r\\n  ListWrapper,\\r\\n  SelectContainer,\\r\\n  Paragraph,\\r\\n  TextHeader,\\r\\n  Checkboxes,\\r\\n  Card,\\r\\n  CardHeader,\\r\\n  CardBody,\\r\\n  OtherSpan,\\r\\n  OptionContainer,\\r\\n  OptionName,\\r\\n  ReactSvg,\\r\\n  ChevronDownSvg\\r\\n} from \'./helpers/styled\';\\r\\n\\r\\nexport default {\\r\\n  title: \'React Functional Select\'\\r\\n};\\r\\n\\r\\nexport const SingleSelect = () => {\\r\\n  const [isInvalid, setIsInvalid] = useCallbackState(false);\\r\\n  const [isLoading, setIsLoading] = useCallbackState(false);\\r\\n  const [isDisabled, setIsDisabled] = useCallbackState(false);\\r\\n  const [isClearable, setIsClearable] = useCallbackState(true);\\r\\n  const [isSearchable, setIsSearchable] = useCallbackState(true);\\r\\n\\r\\n  const getOptionValue = useCallback((option: CityOption): number => option.id, []);\\r\\n  const getOptionLabel = useCallback((option: CityOption): string => `${option.city}, ${option.state}`, []);\\r\\n\\r\\n  useEffect(() => {\\r\\n    isDisabled && setIsInvalid(false);\\r\\n  }, [isDisabled]);\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Single-select</Title>\\r\\n      <Hr />\\r\\n      <Paragraph>\\r\\n        In this story\'s source code, notice that the callback function\\r\\n        properties <code>getOptionValue</code> and <code>getOptionLabel</code> are\\r\\n        wrapped in a <code>useCallback</code>. While not required, <em> strongly prefer </em>\\r\\n        memoization of any callback function property whenever possible. This will boost\\r\\n        performance and reduce the amount of renders as these properties are referenced\\r\\n        in the dependency arrays of <code>useCallbacks</code>, <code>useEffects</code>,\\r\\n        and <code>useMemos</code>. When defined in a functional component, wrap in\\r\\n        a <code>useCallback</code>; when defined in a legacy class component, ensure proper\\r\\n        binding to <code>this</code>. Alternatively, if there is no dependency on any state,\\r\\n        you can opt to hoist functions outside of the component entirely.\\r\\n      </Paragraph>\\r\\n      <Paragraph>\\r\\n        The <code>options</code> property should also be memoized. Either consume\\r\\n        it directly from a state management store, or make sure it is stable by\\r\\n        avoiding inline or render-based mutations.\\r\\n      </Paragraph>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Checkboxes>\\r\\n            <Checkbox\\r\\n              label=\'Searchable\'\\r\\n              checked={isSearchable}\\r\\n              onCheck={setIsSearchable}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'Clearable\'\\r\\n              checked={isClearable}\\r\\n              onCheck={setIsClearable}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'Disabled\'\\r\\n              checked={isDisabled}\\r\\n              onCheck={setIsDisabled}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'Invalid\'\\r\\n              checked={isInvalid}\\r\\n              readOnly={isDisabled}\\r\\n              onCheck={setIsInvalid}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'Loading\'\\r\\n              checked={isLoading}\\r\\n              onCheck={setIsLoading}\\r\\n            />\\r\\n          </Checkboxes>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <SelectContainer>\\r\\n            <Select\\r\\n              isLoading={isLoading}\\r\\n              isInvalid={isInvalid}\\r\\n              options={CITY_OPTIONS}\\r\\n              isDisabled={isDisabled}\\r\\n              isClearable={isClearable}\\r\\n              isSearchable={isSearchable}\\r\\n              getOptionValue={getOptionValue}\\r\\n              getOptionLabel={getOptionLabel}\\r\\n            />\\r\\n          </SelectContainer>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport const MultiSelect = () => {\\r\\n  const [openMenuOnClick, setOpenMenuOnClick] = useCallbackState(true);\\r\\n  const [closeMenuOnSelect, setCloseMenuOnSelect] = useCallbackState(true);\\r\\n  const [blurInputOnSelect, setBlurInputOnSelect] = useCallbackState(false);\\r\\n  const [hideSelectedOptions, setHideSelectedOptions] = useCallbackState(true);\\r\\n  const [useRenderMultiOptions, setUseRenderMultiOptions] = useCallbackState(false);\\r\\n\\r\\n  const getOptionValue = useCallback((option: CityOption): number => option.id, []);\\r\\n  const getOptionLabel = useCallback((option: CityOption): string => `${option.city}, ${option.state}`, []);\\r\\n\\r\\n  // Example \\"renderMultiOptions\\" property that can be used to further customize labeling for multi-option scenarios\\r\\n  const renderMultiOptions = useCallback(\\r\\n    ({ selected, renderOptionLabel }: MultiParams): ReactNode => (\\r\\n      <Fragment>\\r\\n        {selected.length && renderOptionLabel(selected[0].data)}\\r\\n        {selected.length > 1 && (\\r\\n          <OtherSpan>\\r\\n            {`(+${selected.length - 1} ${selected.length === 2 ? \'other\' : \'others\'})`}\\r\\n          </OtherSpan>\\r\\n        )}\\r\\n      </Fragment>\\r\\n    ),\\r\\n    []\\r\\n  );\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Multi-select</Title>\\r\\n      <Hr />\\r\\n      <ListWrapper>\\r\\n        Add the <code>isMulti</code> property to allow for multiple selections.\\r\\n        While in multi-select mode, some properties are now applicable and\\r\\n        others become more pertinent.\\r\\n        <List>\\r\\n          <Li>\\r\\n            <TextHeader>hideSelectedOptions?: boolean</TextHeader> - Hide the\\r\\n            selected option from the menu. Default value is false, however, if\\r\\n            undefined and <code>isMulti === true</code>, then its value defaults\\r\\n            to true.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>closeMenuOnSelect?: boolean</TextHeader> - Close the\\r\\n            menu of options when the user selects an option. Default value is\\r\\n            false, however, it may be benefical to set this property to true for\\r\\n            convenience in multi-select scenarios.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>renderMultiOptions(params: MultiParams): ReactNode</TextHeader> -\\r\\n            Optional callback function that can be used to further customize the selection label\\r\\n            in multi-select scenarios. <code>params</code> is an object that contains\\r\\n            the <code>selected</code> and <code>renderOptionLabel</code> properties (array\\r\\n            of selected options and function used to render individual option labels, respectively).\\r\\n            When this function is defined, left and right arrow navigation of individual options is\\r\\n            disabled. When using this property, it may be be a good idea to set the\\r\\n            property <code>backspaceClearsValue</code> to <em>false</em> in order to avoid accidentally\\r\\n            clearing all selections when searching.\\r\\n          </Li>\\r\\n        </List>\\r\\n      </ListWrapper>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Checkboxes>\\r\\n            <Checkbox\\r\\n              label=\'closeMenuOnSelect\'\\r\\n              checked={closeMenuOnSelect}\\r\\n              onCheck={setCloseMenuOnSelect}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'hideSelectedOptions\'\\r\\n              checked={hideSelectedOptions}\\r\\n              onCheck={setHideSelectedOptions}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'blurInputOnSelect\'\\r\\n              checked={blurInputOnSelect}\\r\\n              onCheck={setBlurInputOnSelect}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'openMenuOnClick (click caret if false)\'\\r\\n              checked={openMenuOnClick}\\r\\n              onCheck={setOpenMenuOnClick}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'renderMultiOptions (custom renderer)\'\\r\\n              checked={useRenderMultiOptions}\\r\\n              onCheck={setUseRenderMultiOptions}\\r\\n            />\\r\\n          </Checkboxes>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <SelectContainer>\\r\\n            <Select\\r\\n              isMulti\\r\\n              isClearable\\r\\n              isSearchable\\r\\n              options={CITY_OPTIONS}\\r\\n              getOptionValue={getOptionValue}\\r\\n              getOptionLabel={getOptionLabel}\\r\\n              openMenuOnClick={openMenuOnClick}\\r\\n              blurInputOnSelect={blurInputOnSelect}\\r\\n              closeMenuOnSelect={closeMenuOnSelect}\\r\\n              hideSelectedOptions={hideSelectedOptions}\\r\\n              backspaceClearsValue={!useRenderMultiOptions}\\r\\n              renderMultiOptions={useRenderMultiOptions ? renderMultiOptions : undefined}\\r\\n            />\\r\\n          </SelectContainer>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport const Styling = () => {\\r\\n  const [themeConfig, setThemeConfig] = useState<Theme>();\\r\\n  const [selectedOption, setSelectedOption] = useCallbackState<SelectedOption | null>(null);\\r\\n  const menuItemSize = (selectedOption && selectedOption.value === ThemeEnum.LARGE_TEXT) ? 44 : 35;\\r\\n\\r\\n  const memoizedMarkupNode = useMemo<ReactNode>(() => (\\r\\n    <CodeMarkup\\r\\n      language=\'markup\'\\r\\n      header=\'Class Markup\'\\r\\n      data={CLASS_NAME_HTML}\\r\\n    />\\r\\n  ), []);\\r\\n\\r\\n  useEffect(() => {\\r\\n    if (selectedOption) {\\r\\n      const { value } = selectedOption;\\r\\n      setThemeConfig(ThemeConfigMap[value]);\\r\\n    }\\r\\n  }, [selectedOption]);\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Styling</Title>\\r\\n      <Hr />\\r\\n      <SubTitle>Theming</SubTitle>\\r\\n      <Columns>\\r\\n        <Column widthPercent={40}>\\r\\n          <Content>\\r\\n            react-functional-select uses <PackageLink {...STYLED_COMPONENTS_PACKAGE} /> to\\r\\n            handle its styling. The root node is wrapped in\\r\\n            styled-component\'s <code>ThemeProvider</code> wrapper component which gives all\\r\\n            child styled-components access to the provided theme via React\'s context API.\\r\\n            To override react-functional-select\'s default theme, pass an object to\\r\\n            the <code>themeConfig</code> property - any matching properties will replace\\r\\n            those in the default theme.\\r\\n          </Content>\\r\\n          <Content>\\r\\n            Starting in <strong>v2.0.0</strong>, some of the nested objects in\\r\\n            the <code>themeConfig</code> object contain a <code>css</code> property\\r\\n            of type <code>string | FlattenSimpleInterpolation | undefined</code> (default value\\r\\n            is undefined). This property can be used to pass raw CSS styles as a string or wrapped\\r\\n            in <PackageLink {...STYLED_COMPONENTS_PACKAGE} /> exported <code>css</code> function.\\r\\n            Those objects are: select, control, icon, menu, noOptions, multiValue, and input.\\r\\n          </Content>\\r\\n          <Content>\\r\\n            Starting in <strong>v2.7.0</strong>, the control object in <code>themeConfig</code> has\\r\\n            the property <code>focusedCss</code> - which is similar to the <code>css</code> property,\\r\\n            except that it is only applied when the select control is focused (and removed when blurred).\\r\\n          </Content>\\r\\n        </Column>\\r\\n        <Column widthPercent={60}>\\r\\n          <CodeMarkup\\r\\n            language=\'javascript\'\\r\\n            data={THEME_DEFAULTS}\\r\\n            header=\'Theme Defaults\'\\r\\n            formatFn={stringifyJavaScriptObj}\\r\\n          />\\r\\n        </Column>\\r\\n      </Columns>\\r\\n      <SubTitle>Using Classes</SubTitle>\\r\\n      <Columns>\\r\\n        <Column widthPercent={40}>\\r\\n          <Content>\\r\\n            If you want to style the component using CSS classes, set the <code>addClassNames</code> prop\\r\\n            to true and it will then generate <code>className</code> attributes for that specific instance\\r\\n            of the component. These are the classes that are available:\\r\\n          </Content>\\r\\n          <ListWrapper className=\'is-class-list\'>\\r\\n            <List>\\r\\n              <Li>{SELECT_CONTAINER_CLS}</Li>\\r\\n              <Li>{CONTROL_CONTAINER_CLS}</Li>\\r\\n              <Li>{MENU_CONTAINER_CLS}</Li>\\r\\n              <Li>{AUTOSIZE_INPUT_CLS}</Li>\\r\\n              <Li>{CARET_ICON_CLS}</Li>\\r\\n              <Li>{CLEAR_ICON_CLS}</Li>\\r\\n              <Li>{LOADING_DOTS_CLS}</Li>\\r\\n              <Li>{`${OPTION_CLS}, ${OPTION_FOCUSED_CLS}, ${OPTION_SELECTED_CLS}, ${OPTION_DISABLED_CLS}`}</Li>\\r\\n            </List>\\r\\n          </ListWrapper>\\r\\n        </Column>\\r\\n        <Column widthPercent={60}>{memoizedMarkupNode}</Column>\\r\\n      </Columns>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Label>Try selecting different themes</Label>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <Columns>\\r\\n            <Column widthPercent={40}>\\r\\n              <div style={{ marginTop: \'1rem\' }}>\\r\\n                <Select\\r\\n                  isClearable={false}\\r\\n                  isSearchable={false}\\r\\n                  options={THEME_OPTIONS}\\r\\n                  themeConfig={themeConfig}\\r\\n                  menuItemSize={menuItemSize}\\r\\n                  initialValue={THEME_OPTIONS[0]}\\r\\n                  onOptionChange={setSelectedOption}\\r\\n                />\\r\\n              </div>\\r\\n            </Column>\\r\\n            <Column widthPercent={60}>\\r\\n              <CodeMarkup\\r\\n                data={themeConfig}\\r\\n                language=\'javascript\'\\r\\n                header=\'theme-config\'\\r\\n                formatFn={stringifyJavaScriptObj}\\r\\n              />\\r\\n            </Column>\\r\\n          </Columns>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport const Events = () => {\\r\\n  const options = useMemo<Option[]>(() => createSelectOptions(5), []);\\r\\n\\r\\n  const [addOnKeyDown, setAddOnKeyDown] = useCallbackState(false);\\r\\n  const [addOnMenuOpen, setAddOnMenuOpen] = useCallbackState(true);\\r\\n  const [addOnMenuClose, setAddOnMenuClose] = useCallbackState(false);\\r\\n  const [addOnInputBlur, setAddOnInputBlur] = useCallbackState(false);\\r\\n  const [addOnInputFocus, setAddOnInputFocus] = useCallbackState(false);\\r\\n  const [addOnOptionChange, setAddOnOptionChange] = useCallbackState(true);\\r\\n\\r\\n  const onOptionChange = useCallback((option: Option | null): void => {\\r\\n    const optionJsonStr = JSON.stringify(option || {}).replace(/\\"/g, \\"\'\\");\\r\\n    renderInfoToast(`Selected Option: ${optionJsonStr}`);\\r\\n  }, []);\\r\\n\\r\\n  const onMenuOpen = useCallback((): void => renderInfoToast(\'Menu opened!\'), []);\\r\\n  const onMenuClose = useCallback((): void => renderInfoToast(\'Menu closed!\'), []);\\r\\n  const onInputBlur = useCallback((): void => renderInfoToast(\'Control blurred!\'), []);\\r\\n  const onInputFocus = useCallback((): void => renderInfoToast(\'Control focused!\'), []);\\r\\n  const onKeyDown = useCallback((): void => renderInfoToast(\'keydown event executed!\'), []);\\r\\n\\r\\n  // Configure reat-toastify onMount and cleanup active toasts on beforeDismount\\r\\n  useEffect(() => {\\r\\n    toast.configure(TOAST_CONTAINER_PROPS);\\r\\n\\r\\n    return () => {\\r\\n      toast.dismiss();\\r\\n    };\\r\\n  }, []);\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Events</Title>\\r\\n      <Hr />\\r\\n      <ListWrapper>\\r\\n        There are various callback function properties that are executed following\\r\\n        their associated events:\\r\\n        <List>\\r\\n          <Li>\\r\\n            <TextHeader>onOptionChange(data: any): void</TextHeader> -\\r\\n            executed after an option is selected or removed\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>onMenuOpen(...args: any[]): void</TextHeader> -\\r\\n            executed after the menu is opened\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>onMenuClose(...args: any[]): void</TextHeader> -\\r\\n            executed after the menu is closed\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>onInputChange(value: string): void</TextHeader> -\\r\\n            executed after the input control\'s value changes\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>onInputBlur(e: FocusEvent&lt;HTMLInputElement&gt;): void</TextHeader> -\\r\\n            executed after the input control is blurred\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>onInputFocus(e: FocusEvent&lt;HTMLInputElement&gt;): void</TextHeader> -\\r\\n            executed after the input control is focused\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>onKeyDown(e: KeyboardEvent&lt;HTMLDivElement&gt;, input?: string, focusedOption?: FocusedOption): void</TextHeader> -\\r\\n            executed after the onKeyDown event\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>onSearchChange(value: string): void</TextHeader> -\\r\\n            executed after the input value is persisted to state; this value also evaluates\\r\\n            the <code>inputDelay</code> property for debouncing - this callback is really only\\r\\n            useful when <code>inputDelay</code> is defined, and if not, it probably makes more\\r\\n            sense to use the <code>onInputChange</code> callback\\r\\n          </Li>\\r\\n        </List>\\r\\n      </ListWrapper>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Label>Events trigger a toast notification</Label>\\r\\n          <Checkboxes>\\r\\n            <Checkbox\\r\\n              label=\'onOptionChange\'\\r\\n              checked={addOnOptionChange}\\r\\n              onCheck={setAddOnOptionChange}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'onMenuOpen\'\\r\\n              checked={addOnMenuOpen}\\r\\n              onCheck={setAddOnMenuOpen}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'onMenuClose\'\\r\\n              checked={addOnMenuClose}\\r\\n              onCheck={setAddOnMenuClose}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'onInputBlur\'\\r\\n              checked={addOnInputBlur}\\r\\n              onCheck={setAddOnInputBlur}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'onInputFocus\'\\r\\n              checked={addOnInputFocus}\\r\\n              onCheck={setAddOnInputFocus}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'onKeyDown\'\\r\\n              checked={addOnKeyDown}\\r\\n              onCheck={setAddOnKeyDown}\\r\\n            />\\r\\n          </Checkboxes>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <SelectContainer>\\r\\n            <Select\\r\\n              options={options}\\r\\n              onKeyDown={addOnKeyDown ? onKeyDown : undefined}\\r\\n              onMenuOpen={addOnMenuOpen ? onMenuOpen : undefined}\\r\\n              onMenuClose={addOnMenuClose ? onMenuClose : undefined}\\r\\n              onInputBlur={addOnInputBlur ? onInputBlur : undefined}\\r\\n              onInputFocus={addOnInputFocus ? onInputFocus : undefined}\\r\\n              onOptionChange={addOnOptionChange ? onOptionChange : undefined}\\r\\n            />\\r\\n          </SelectContainer>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport const Methods = () => {\\r\\n  const selectRef = useRef<SelectRef | null>(null);\\r\\n  const options = useMemo<Option[]>(() => createSelectOptions(5), []);\\r\\n\\r\\n  const blurSelect = (): void => {\\r\\n    selectRef.current && selectRef.current.blur();\\r\\n  };\\r\\n\\r\\n  const focusSelect = (): void => {\\r\\n    selectRef.current && selectRef.current.focus();\\r\\n  };\\r\\n\\r\\n  const clearValue = (): void => {\\r\\n    selectRef.current && selectRef.current.clearValue();\\r\\n  };\\r\\n\\r\\n  const toggleMenuOpen = (): void => {\\r\\n    selectRef.current && selectRef.current.toggleMenu(true);\\r\\n  };\\r\\n\\r\\n  const updateSelectedOption = (): void => {\\r\\n    selectRef.current && selectRef.current.setValue(options[0]);\\r\\n  };\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Methods</Title>\\r\\n      <Hr />\\r\\n      <ListWrapper>\\r\\n        Five public methods are exposed to wrapping components and are\\r\\n        accessible via a forwarded <code>ref</code>.\\r\\n        <List>\\r\\n          <Li>\\r\\n            <TextHeader>blur(): void</TextHeader> - blur the control\\r\\n            programatically\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>focus(): void</TextHeader> - focus the control\\r\\n            programatically\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>toggleMenu(state?: boolean): void</TextHeader> -\\r\\n            toggle the menu programatically\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>clearValue(): void</TextHeader> - clear the current\\r\\n            value programatically <em>(if an option is selected)</em>\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>setValue(option?: any): void</TextHeader> - set the\\r\\n            value programatically <em>(option will be validated)</em>\\r\\n          </Li>\\r\\n        </List>\\r\\n      </ListWrapper>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Label>Methods</Label>\\r\\n          <Buttons>\\r\\n            <Button onClick={focusSelect}>Focus</Button>\\r\\n            <Button onClick={blurSelect}>Blur</Button>\\r\\n            <Button onClick={toggleMenuOpen}>Open Menu</Button>\\r\\n            <Button onClick={clearValue}>Clear Value</Button>\\r\\n            <Button onClick={updateSelectedOption}>Set Value (1st Option)</Button>\\r\\n          </Buttons>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <SelectContainer>\\r\\n            <Select\\r\\n              ref={selectRef}\\r\\n              options={options}\\r\\n              initialValue={options[0]}\\r\\n            />\\r\\n          </SelectContainer>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport const Filtering = () => {\\r\\n  const [filterIgnoreCase, setFilterIgnoreCase] = useCallbackState(true);\\r\\n  const [useCustomFilterFunc, setUseCustomFilterFunc] = useCallbackState(false);\\r\\n  const [filterIgnoreAccents, setFilterIgnoreAccents] = useCallbackState(false);\\r\\n  const [filterMatchFromStart, setFilterMatchFromStart] = useCallbackState(false);\\r\\n\\r\\n  const getOptionValue = useCallback((option: CityOption): number => option.id, []);\\r\\n  const getOptionLabel = useCallback((option: CityOption): string => `${option.city}, ${option.state}`, []);\\r\\n  const getFilterOptionString = useCallback((menuOption: MenuOption): string => menuOption.data.state, []);\\r\\n\\r\\n  const options = useMemo<CityOption[]>(() => [...CITY_OPTIONS, { id: 11, city: \'So Paulo\', state: \'BR\' }], []);\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Filter Customization</Title>\\r\\n      <Hr />\\r\\n      <ListWrapper>\\r\\n        The default filtering functionality can be customized via the following properties:\\r\\n        <List>\\r\\n          <Li>\\r\\n            <TextHeader>filterIgnoreCase?: boolean</TextHeader> - Filter ignores\\r\\n            case when matching strings. Default value is <code>true</code>.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>filterIgnoreAccents?: boolean</TextHeader> - Filter\\r\\n            ignores accents when matching strings. Default value is <code>false</code>.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>filterMatchFrom?: \'any\' | \'start\'</TextHeader> -\\r\\n            Position in source string to perform match. Default value is <code>\'any\'</code>.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>getFilterOptionString(option: MenuOption): string</TextHeader> -\\r\\n            When defined will take each option and generate a string used in\\r\\n            the filtering process. By default, the stringified version of what is\\r\\n            generated by <code>getOptionLabel</code>, if definded, or the option\'s label\\r\\n            as a fallback. The <code>MenuOption</code> typed parameter\\r\\n            that <code>getFilterOptionString</code> accepts contains a <code>data</code> property\\r\\n            that represents the objects that comprise your <code>options</code> property.\\r\\n          </Li>\\r\\n        </List>\\r\\n      </ListWrapper>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Checkboxes>\\r\\n            <Checkbox\\r\\n              label=\'Ignore Case\'\\r\\n              checked={filterIgnoreCase}\\r\\n              onCheck={setFilterIgnoreCase}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'Ignore Accents\'\\r\\n              checked={filterIgnoreAccents}\\r\\n              onCheck={setFilterIgnoreAccents}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'Match from the start\'\\r\\n              checked={filterMatchFromStart}\\r\\n              onCheck={setFilterMatchFromStart}\\r\\n            />\\r\\n            <Checkbox\\r\\n              label=\'Use custom filter function (by state only)\'\\r\\n              checked={useCustomFilterFunc}\\r\\n              onCheck={setUseCustomFilterFunc}\\r\\n            />\\r\\n          </Checkboxes>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <SelectContainer>\\r\\n            <Select\\r\\n              isClearable\\r\\n              options={options}\\r\\n              getOptionValue={getOptionValue}\\r\\n              getOptionLabel={getOptionLabel}\\r\\n              filterIgnoreCase={filterIgnoreCase}\\r\\n              filterIgnoreAccents={filterIgnoreAccents}\\r\\n              getFilterOptionString={useCustomFilterFunc ? getFilterOptionString : undefined}\\r\\n              filterMatchFrom={filterMatchFromStart ? FilterMatchEnum.START : FilterMatchEnum.ANY}\\r\\n            />\\r\\n          </SelectContainer>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport const Windowing = () => {\\r\\n  const optionCountList: number[] = [100, 1000, 5000, 25000, 50000];\\r\\n\\r\\n  const selectRef = useRef<SelectRef | null>(null);\\r\\n  const [options, setOptions] = useState<Option[]>([]);\\r\\n  const [optionsCount, setOptionsCount] = useState<number>(optionCountList[0]);\\r\\n\\r\\n  useUpdateEffect(() => {\\r\\n    selectRef.current && selectRef.current.clearValue();\\r\\n  }, [options]);\\r\\n\\r\\n  useEffect(() => {\\r\\n    const nextSelectOptions = createSelectOptions(optionsCount);\\r\\n    setOptions(nextSelectOptions);\\r\\n  }, [optionsCount]);\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Integrated Windowing</Title>\\r\\n      <Hr />\\r\\n      <ListWrapper>\\r\\n        Option data is \'windowed\' using the{\' \'}\\r\\n        <PackageLink {...REACT_WINDOW_PACKAGE} /> package. Aside from the\\r\\n        obvious benefits provided by only rendering a small subset of your\\r\\n        enumerable data (rather than bloating the DOM with an excessive amount\\r\\n        of nodes), \'windowing\' can also assist with:\\r\\n        <List>\\r\\n          <Li>\\r\\n            <strong>Efficient memory allocation</strong>. \'Windowing\' naturally\\r\\n            lends itself to the dynamic generation of attributes/values as each\\r\\n            object comes into your renderer\'s scope (as opposed to allocating\\r\\n            this data upfront for each object in your list). This way you can\\r\\n            perform this work just when you absolutely need to and then can\\r\\n            immediately release it for the GC to cleanup. As an example I am\\r\\n            generating the <code>onClick</code>, <code>id</code>, and{\' \'}\\r\\n            <code>className</code> attributes for each <code>menuOption</code>{\' \'}\\r\\n            as they get passed to the <code>&lt;Option /&gt;</code> renderer\\r\\n            component.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <strong>Functional architecture</strong>. The flexibility provided\\r\\n            through only having to manage subsets of your list allows for a more\\r\\n            dynamic application. By breaking your code out into smaller, \'pure\'\\r\\n            child components, you can write code that scales well and becomes\\r\\n            open to performance optimizations - most notably, memoization.\\r\\n            Simple components that rely on the props passed to it (rather than\\r\\n            its own managed state) to generate its JSX are likely candidates for\\r\\n            memoization (testing &amp; debugging becomes much easier as well).\\r\\n          </Li>\\r\\n        </List>\\r\\n        <em>Note: </em>The only time any noticeable performance degradation will\\r\\n        be observed is during search input updates when the <code>options</code>{\' \'}\\r\\n        count reaches the high tens of thousands. To work around this, the{\' \'}\\r\\n        <code>inputDelay</code> (number in milliseconds) can be set to debounce\\r\\n        the input value. That way, the <code>menuOptions</code> will not be\\r\\n        recalculated on every keystroke.\\r\\n      </ListWrapper>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Label>Options Count</Label>\\r\\n          <Buttons>\\r\\n            {optionCountList.map((count) => (\\r\\n              <OptionsCountButton\\r\\n                key={count}\\r\\n                count={count}\\r\\n                optionsCount={optionsCount}\\r\\n                setOptionsCount={setOptionsCount}\\r\\n              />\\r\\n            ))}\\r\\n          </Buttons>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <SelectContainer>\\r\\n            <Select ref={selectRef} options={options} />\\r\\n          </SelectContainer>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport const Advanced = () => {\\r\\n  const getOptionValue = useCallback((option: PackageOption): number => option.id, []);\\r\\n  const getIsOptionDisabled = useCallback((option: PackageOption): boolean => (option.name === PACKAGE_OPTIONS[3].name), []);\\r\\n\\r\\n  const renderOptionLabel = useCallback(\\r\\n    (option: PackageOption): ReactNode => (\\r\\n      <OptionContainer>\\r\\n        <ReactSvg\\r\\n          aria-hidden=\'true\'\\r\\n          viewBox=\'0 0 841.9 595.3\'\\r\\n          isDisabled={getIsOptionDisabled(option)}\\r\\n        >\\r\\n          <path d=\\"M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z\\" />\\r\\n          <circle cx=\\"420.9\\" cy=\\"296.5\\" r=\\"45.7\\" />\\r\\n        </ReactSvg>\\r\\n        <OptionName>{option.name}</OptionName>\\r\\n      </OptionContainer>\\r\\n    ),\\r\\n    [getIsOptionDisabled]\\r\\n  );\\r\\n\\r\\n  const customCaretIcon = useCallback(\\r\\n    ({ menuOpen }): ReactNode => (\\r\\n      <ChevronDownSvg menuOpen={menuOpen} aria-hidden=\'true\' viewBox=\'0 0 448 512\'>\\r\\n        <path d=\'M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z\' />\\r\\n      </ChevronDownSvg>\\r\\n    ),\\r\\n    []\\r\\n  );\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Advanced Customization</Title>\\r\\n      <Hr />\\r\\n      <ListWrapper>\\r\\n        Implementation using a couple of the more specialized properties.\\r\\n        <List>\\r\\n          <Li>\\r\\n            <TextHeader>renderOptionLabel(option: any): React.ReactNode</TextHeader> - Callback\\r\\n            function with a return type of <code>ReactNode</code>. Use this property in cases\\r\\n            where the standard <code>getOptionLabel</code> property won\'t meet your needs (for\\r\\n            instance, you want to render each option\'s label using custom JSX). More complex\\r\\n            option labels will likely equate to longer render durations - this can translate\\r\\n            into a flash of empty space when a user first starts scrolling. In order to prevent\\r\\n            this, the <code>menuOverscanCount</code> property can be increased to render additional\\r\\n            rows outside of the visible area. The default value for this property is 1 and it is\\r\\n            important to note that increasing this value can negatively impact performance.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>getIsOptionDisabled(option: any): boolean</TextHeader> - Callback\\r\\n            function with a return type of <code>Boolean</code>. When it evaluates to a value of\\r\\n            true, that option iteration will be rendered <em>disabled</em>. As an alternative, you\\r\\n            can also pass a property of <code>isDisabled</code> with each option. Use of these two\\r\\n            options - they cannot both be specified.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>caretIcon: ReactNode | (...args: any[]) =&gt; ReactNode</TextHeader> - A custom\\r\\n            node or a function that returns a node can used for the <code>caretIcon</code> property.\\r\\n            When using a function, an object containing stateful data is forwarded and can be used to style\\r\\n            your custom node accordingly. The state is <code>{\'{ menuOpen, isLoading, isInvalid, isDisabled }\'}</code> of\\r\\n            type <code>Record&lt;string, boolean&gt;</code>. The <code>clearIcon</code> property has an identical definition.\\r\\n          </Li>\\r\\n        </List>\\r\\n      </ListWrapper>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Label>JSX labels, custom caret icon, and disabled option</Label>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <SelectContainer>\\r\\n            <Select\\r\\n              isSearchable={false}\\r\\n              options={PACKAGE_OPTIONS}\\r\\n              themeConfig={THEME_CONFIG}\\r\\n              caretIcon={customCaretIcon}\\r\\n              getOptionValue={getOptionValue}\\r\\n              renderOptionLabel={renderOptionLabel}\\r\\n              getIsOptionDisabled={getIsOptionDisabled}\\r\\n            />\\r\\n          </SelectContainer>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport const Async = () => {\\r\\n  const [isLoading, setIsLoading] = useState<boolean>(false);\\r\\n  const [options, setOptions] = useState<Option[]>(() => createAsyncOptions(5, \'Initial\'));\\r\\n\\r\\n  const onInputChange = useCallback((): void => setIsLoading(true), []);\\r\\n\\r\\n  const onSearchChange = useCallback((value?: string): void => {\\r\\n    mockHttpRequest()\\r\\n      .then(() => {\\r\\n        const nextOptions = createAsyncOptions(\\r\\n          getRandomInt(1, 5),\\r\\n          `Search text: ${value || \'Initial\'}`\\r\\n        );\\r\\n\\r\\n        setOptions(nextOptions);\\r\\n      })\\r\\n      .catch((err) => console.error(err))\\r\\n      .then(() => setIsLoading(false));\\r\\n  }, []);\\r\\n\\r\\n  return (\\r\\n    <Container>\\r\\n      <Title>Async Mode</Title>\\r\\n      <Hr />\\r\\n      <ListWrapper>\\r\\n        Add the <code>async</code> property to enable async mode. There is one key\\r\\n        difference in core functionality with async mode - changes to search input\\r\\n        value will not cause the <code>useMenuOptions</code> effect to run. The rest\\r\\n        of hooking into async mode is achieved using some combination of the properties\\r\\n        found below. <em>Properties onInputChange and onSearchChange should be memoized.</em>\\r\\n        <List>\\r\\n          <Li>\\r\\n            <TextHeader>onInputChange(value: string): void</TextHeader> -\\r\\n            callback executed directly following the input control\'s <code>onChange</code> event.\\r\\n            This callback is not debounced, so it fires immediately. This is a good\\r\\n            place to set a stateful loading property in your parent component that is mapped to\\r\\n            react-functional-select\'s <code>isLoading</code> property.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>onSearchChange(value: string): void</TextHeader> -\\r\\n            callback executed following component state updates for\\r\\n            the <code>debouncedInputValue</code>. The debounce is set using\\r\\n            the <code>inputDelay</code> property. This callback is a good place for your\\r\\n            http fetch request and post-request logic (i.e. setting isLoading false).\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>inputDelay?: number</TextHeader> - As mentioned above, this can be\\r\\n            set to a positive integer in order to debounce updates to the search input value\\r\\n            following input change events. This property directly maps to the <code>delay</code> in\\r\\n            milliconds passed to the <code>setTimeout</code> method.\\r\\n          </Li>\\r\\n          <Li>\\r\\n            <TextHeader>isLoading?: boolean</TextHeader> - When true, a loading animation will\\r\\n            appear in the far-right of the control and take the place of the clear icon (if shown).\\r\\n            Additionally, it will hide options in the menu and instead, display a loading message.\\r\\n            The loading message text defaults to \'Loading...\', but can be overriden via\\r\\n            the <code>loadingMsg</code> property.\\r\\n          </Li>\\r\\n        </List>\\r\\n      </ListWrapper>\\r\\n      <SubTitle>Demo</SubTitle>\\r\\n      <Hr />\\r\\n      <Card>\\r\\n        <CardHeader>\\r\\n          <Label>Search debounced 500ms and mock HTTP call resolves after 500ms</Label>\\r\\n        </CardHeader>\\r\\n        <CardBody>\\r\\n          <SelectContainer>\\r\\n            <Select\\r\\n              async\\r\\n              isClearable\\r\\n              inputDelay={500}\\r\\n              options={options}\\r\\n              isLoading={isLoading}\\r\\n              onInputChange={onInputChange}\\r\\n              onSearchChange={onSearchChange}\\r\\n            />\\r\\n          </SelectContainer>\\r\\n        </CardBody>\\r\\n      </Card>\\r\\n    </Container>\\r\\n  );\\r\\n};","locationsMap":{"single-select":{"startLoc":{"col":28,"line":79},"endLoc":{"col":1,"line":164},"startBody":{"col":28,"line":79},"endBody":{"col":1,"line":164}},"multi-select":{"startLoc":{"col":27,"line":166},"endLoc":{"col":1,"line":278},"startBody":{"col":27,"line":166},"endBody":{"col":1,"line":278}},"styling":{"startLoc":{"col":23,"line":280},"endLoc":{"col":1,"line":396},"startBody":{"col":23,"line":280},"endBody":{"col":1,"line":396}},"events":{"startLoc":{"col":22,"line":398},"endLoc":{"col":1,"line":527},"startBody":{"col":22,"line":398},"endBody":{"col":1,"line":527}},"methods":{"startLoc":{"col":23,"line":529},"endLoc":{"col":1,"line":608},"startBody":{"col":23,"line":529},"endBody":{"col":1,"line":608}},"filtering":{"startLoc":{"col":25,"line":610},"endLoc":{"col":1,"line":696},"startBody":{"col":25,"line":610},"endBody":{"col":1,"line":696}},"windowing":{"startLoc":{"col":25,"line":698},"endLoc":{"col":1,"line":779},"startBody":{"col":25,"line":698},"endBody":{"col":1,"line":779}},"advanced":{"startLoc":{"col":24,"line":781},"endLoc":{"col":1,"line":867},"startBody":{"col":24,"line":781},"endBody":{"col":1,"line":867}},"async":{"startLoc":{"col":21,"line":869},"endLoc":{"col":1,"line":951},"startBody":{"col":21,"line":869},"endBody":{"col":1,"line":951}}}},},\r\n  title: \'React Functional Select\'\r\n};\r\n\r\nexport const SingleSelect = () => {\r\n  const [isInvalid, setIsInvalid] = useCallbackState(false);\r\n  const [isLoading, setIsLoading] = useCallbackState(false);\r\n  const [isDisabled, setIsDisabled] = useCallbackState(false);\r\n  const [isClearable, setIsClearable] = useCallbackState(true);\r\n  const [isSearchable, setIsSearchable] = useCallbackState(true);\r\n\r\n  const getOptionValue = useCallback((option: CityOption): number => option.id, []);\r\n  const getOptionLabel = useCallback((option: CityOption): string => `${option.city}, ${option.state}`, []);\r\n\r\n  useEffect(() => {\r\n    isDisabled && setIsInvalid(false);\r\n  }, [isDisabled]);\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Single-select</Title>\r\n      <Hr />\r\n      <Paragraph>\r\n        In this story\'s source code, notice that the callback function\r\n        properties <code>getOptionValue</code> and <code>getOptionLabel</code> are\r\n        wrapped in a <code>useCallback</code>. While not required, <em> strongly prefer </em>\r\n        memoization of any callback function property whenever possible. This will boost\r\n        performance and reduce the amount of renders as these properties are referenced\r\n        in the dependency arrays of <code>useCallbacks</code>, <code>useEffects</code>,\r\n        and <code>useMemos</code>. When defined in a functional component, wrap in\r\n        a <code>useCallback</code>; when defined in a legacy class component, ensure proper\r\n        binding to <code>this</code>. Alternatively, if there is no dependency on any state,\r\n        you can opt to hoist functions outside of the component entirely.\r\n      </Paragraph>\r\n      <Paragraph>\r\n        The <code>options</code> property should also be memoized. Either consume\r\n        it directly from a state management store, or make sure it is stable by\r\n        avoiding inline or render-based mutations.\r\n      </Paragraph>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Checkboxes>\r\n            <Checkbox\r\n              label=\'Searchable\'\r\n              checked={isSearchable}\r\n              onCheck={setIsSearchable}\r\n            />\r\n            <Checkbox\r\n              label=\'Clearable\'\r\n              checked={isClearable}\r\n              onCheck={setIsClearable}\r\n            />\r\n            <Checkbox\r\n              label=\'Disabled\'\r\n              checked={isDisabled}\r\n              onCheck={setIsDisabled}\r\n            />\r\n            <Checkbox\r\n              label=\'Invalid\'\r\n              checked={isInvalid}\r\n              readOnly={isDisabled}\r\n              onCheck={setIsInvalid}\r\n            />\r\n            <Checkbox\r\n              label=\'Loading\'\r\n              checked={isLoading}\r\n              onCheck={setIsLoading}\r\n            />\r\n          </Checkboxes>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <SelectContainer>\r\n            <Select\r\n              isLoading={isLoading}\r\n              isInvalid={isInvalid}\r\n              options={CITY_OPTIONS}\r\n              isDisabled={isDisabled}\r\n              isClearable={isClearable}\r\n              isSearchable={isSearchable}\r\n              getOptionValue={getOptionValue}\r\n              getOptionLabel={getOptionLabel}\r\n            />\r\n          </SelectContainer>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};;\r\n\r\nexport const MultiSelect = () => {\r\n  const [openMenuOnClick, setOpenMenuOnClick] = useCallbackState(true);\r\n  const [closeMenuOnSelect, setCloseMenuOnSelect] = useCallbackState(true);\r\n  const [blurInputOnSelect, setBlurInputOnSelect] = useCallbackState(false);\r\n  const [hideSelectedOptions, setHideSelectedOptions] = useCallbackState(true);\r\n  const [useRenderMultiOptions, setUseRenderMultiOptions] = useCallbackState(false);\r\n\r\n  const getOptionValue = useCallback((option: CityOption): number => option.id, []);\r\n  const getOptionLabel = useCallback((option: CityOption): string => `${option.city}, ${option.state}`, []);\r\n\r\n  // Example "renderMultiOptions" property that can be used to further customize labeling for multi-option scenarios\r\n  const renderMultiOptions = useCallback(\r\n    ({ selected, renderOptionLabel }: MultiParams): ReactNode => (\r\n      <Fragment>\r\n        {selected.length && renderOptionLabel(selected[0].data)}\r\n        {selected.length > 1 && (\r\n          <OtherSpan>\r\n            {`(+${selected.length - 1} ${selected.length === 2 ? \'other\' : \'others\'})`}\r\n          </OtherSpan>\r\n        )}\r\n      </Fragment>\r\n    ),\r\n    []\r\n  );\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Multi-select</Title>\r\n      <Hr />\r\n      <ListWrapper>\r\n        Add the <code>isMulti</code> property to allow for multiple selections.\r\n        While in multi-select mode, some properties are now applicable and\r\n        others become more pertinent.\r\n        <List>\r\n          <Li>\r\n            <TextHeader>hideSelectedOptions?: boolean</TextHeader> - Hide the\r\n            selected option from the menu. Default value is false, however, if\r\n            undefined and <code>isMulti === true</code>, then its value defaults\r\n            to true.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>closeMenuOnSelect?: boolean</TextHeader> - Close the\r\n            menu of options when the user selects an option. Default value is\r\n            false, however, it may be benefical to set this property to true for\r\n            convenience in multi-select scenarios.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>renderMultiOptions(params: MultiParams): ReactNode</TextHeader> -\r\n            Optional callback function that can be used to further customize the selection label\r\n            in multi-select scenarios. <code>params</code> is an object that contains\r\n            the <code>selected</code> and <code>renderOptionLabel</code> properties (array\r\n            of selected options and function used to render individual option labels, respectively).\r\n            When this function is defined, left and right arrow navigation of individual options is\r\n            disabled. When using this property, it may be be a good idea to set the\r\n            property <code>backspaceClearsValue</code> to <em>false</em> in order to avoid accidentally\r\n            clearing all selections when searching.\r\n          </Li>\r\n        </List>\r\n      </ListWrapper>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Checkboxes>\r\n            <Checkbox\r\n              label=\'closeMenuOnSelect\'\r\n              checked={closeMenuOnSelect}\r\n              onCheck={setCloseMenuOnSelect}\r\n            />\r\n            <Checkbox\r\n              label=\'hideSelectedOptions\'\r\n              checked={hideSelectedOptions}\r\n              onCheck={setHideSelectedOptions}\r\n            />\r\n            <Checkbox\r\n              label=\'blurInputOnSelect\'\r\n              checked={blurInputOnSelect}\r\n              onCheck={setBlurInputOnSelect}\r\n            />\r\n            <Checkbox\r\n              label=\'openMenuOnClick (click caret if false)\'\r\n              checked={openMenuOnClick}\r\n              onCheck={setOpenMenuOnClick}\r\n            />\r\n            <Checkbox\r\n              label=\'renderMultiOptions (custom renderer)\'\r\n              checked={useRenderMultiOptions}\r\n              onCheck={setUseRenderMultiOptions}\r\n            />\r\n          </Checkboxes>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <SelectContainer>\r\n            <Select\r\n              isMulti\r\n              isClearable\r\n              isSearchable\r\n              options={CITY_OPTIONS}\r\n              getOptionValue={getOptionValue}\r\n              getOptionLabel={getOptionLabel}\r\n              openMenuOnClick={openMenuOnClick}\r\n              blurInputOnSelect={blurInputOnSelect}\r\n              closeMenuOnSelect={closeMenuOnSelect}\r\n              hideSelectedOptions={hideSelectedOptions}\r\n              backspaceClearsValue={!useRenderMultiOptions}\r\n              renderMultiOptions={useRenderMultiOptions ? renderMultiOptions : undefined}\r\n            />\r\n          </SelectContainer>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};;\r\n\r\nexport const Styling = () => {\r\n  const [themeConfig, setThemeConfig] = useState<Theme>();\r\n  const [selectedOption, setSelectedOption] = useCallbackState<SelectedOption | null>(null);\r\n  const menuItemSize = (selectedOption && selectedOption.value === ThemeEnum.LARGE_TEXT) ? 44 : 35;\r\n\r\n  const memoizedMarkupNode = useMemo<ReactNode>(() => (\r\n    <CodeMarkup\r\n      language=\'markup\'\r\n      header=\'Class Markup\'\r\n      data={CLASS_NAME_HTML}\r\n    />\r\n  ), []);\r\n\r\n  useEffect(() => {\r\n    if (selectedOption) {\r\n      const { value } = selectedOption;\r\n      setThemeConfig(ThemeConfigMap[value]);\r\n    }\r\n  }, [selectedOption]);\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Styling</Title>\r\n      <Hr />\r\n      <SubTitle>Theming</SubTitle>\r\n      <Columns>\r\n        <Column widthPercent={40}>\r\n          <Content>\r\n            react-functional-select uses <PackageLink {...STYLED_COMPONENTS_PACKAGE} /> to\r\n            handle its styling. The root node is wrapped in\r\n            styled-component\'s <code>ThemeProvider</code> wrapper component which gives all\r\n            child styled-components access to the provided theme via React\'s context API.\r\n            To override react-functional-select\'s default theme, pass an object to\r\n            the <code>themeConfig</code> property - any matching properties will replace\r\n            those in the default theme.\r\n          </Content>\r\n          <Content>\r\n            Starting in <strong>v2.0.0</strong>, some of the nested objects in\r\n            the <code>themeConfig</code> object contain a <code>css</code> property\r\n            of type <code>string | FlattenSimpleInterpolation | undefined</code> (default value\r\n            is undefined). This property can be used to pass raw CSS styles as a string or wrapped\r\n            in <PackageLink {...STYLED_COMPONENTS_PACKAGE} /> exported <code>css</code> function.\r\n            Those objects are: select, control, icon, menu, noOptions, multiValue, and input.\r\n          </Content>\r\n          <Content>\r\n            Starting in <strong>v2.7.0</strong>, the control object in <code>themeConfig</code> has\r\n            the property <code>focusedCss</code> - which is similar to the <code>css</code> property,\r\n            except that it is only applied when the select control is focused (and removed when blurred).\r\n          </Content>\r\n        </Column>\r\n        <Column widthPercent={60}>\r\n          <CodeMarkup\r\n            language=\'javascript\'\r\n            data={THEME_DEFAULTS}\r\n            header=\'Theme Defaults\'\r\n            formatFn={stringifyJavaScriptObj}\r\n          />\r\n        </Column>\r\n      </Columns>\r\n      <SubTitle>Using Classes</SubTitle>\r\n      <Columns>\r\n        <Column widthPercent={40}>\r\n          <Content>\r\n            If you want to style the component using CSS classes, set the <code>addClassNames</code> prop\r\n            to true and it will then generate <code>className</code> attributes for that specific instance\r\n            of the component. These are the classes that are available:\r\n          </Content>\r\n          <ListWrapper className=\'is-class-list\'>\r\n            <List>\r\n              <Li>{SELECT_CONTAINER_CLS}</Li>\r\n              <Li>{CONTROL_CONTAINER_CLS}</Li>\r\n              <Li>{MENU_CONTAINER_CLS}</Li>\r\n              <Li>{AUTOSIZE_INPUT_CLS}</Li>\r\n              <Li>{CARET_ICON_CLS}</Li>\r\n              <Li>{CLEAR_ICON_CLS}</Li>\r\n              <Li>{LOADING_DOTS_CLS}</Li>\r\n              <Li>{`${OPTION_CLS}, ${OPTION_FOCUSED_CLS}, ${OPTION_SELECTED_CLS}, ${OPTION_DISABLED_CLS}`}</Li>\r\n            </List>\r\n          </ListWrapper>\r\n        </Column>\r\n        <Column widthPercent={60}>{memoizedMarkupNode}</Column>\r\n      </Columns>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Label>Try selecting different themes</Label>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <Columns>\r\n            <Column widthPercent={40}>\r\n              <div style={{ marginTop: \'1rem\' }}>\r\n                <Select\r\n                  isClearable={false}\r\n                  isSearchable={false}\r\n                  options={THEME_OPTIONS}\r\n                  themeConfig={themeConfig}\r\n                  menuItemSize={menuItemSize}\r\n                  initialValue={THEME_OPTIONS[0]}\r\n                  onOptionChange={setSelectedOption}\r\n                />\r\n              </div>\r\n            </Column>\r\n            <Column widthPercent={60}>\r\n              <CodeMarkup\r\n                data={themeConfig}\r\n                language=\'javascript\'\r\n                header=\'theme-config\'\r\n                formatFn={stringifyJavaScriptObj}\r\n              />\r\n            </Column>\r\n          </Columns>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};;\r\n\r\nexport const Events = () => {\r\n  const options = useMemo<Option[]>(() => createSelectOptions(5), []);\r\n\r\n  const [addOnKeyDown, setAddOnKeyDown] = useCallbackState(false);\r\n  const [addOnMenuOpen, setAddOnMenuOpen] = useCallbackState(true);\r\n  const [addOnMenuClose, setAddOnMenuClose] = useCallbackState(false);\r\n  const [addOnInputBlur, setAddOnInputBlur] = useCallbackState(false);\r\n  const [addOnInputFocus, setAddOnInputFocus] = useCallbackState(false);\r\n  const [addOnOptionChange, setAddOnOptionChange] = useCallbackState(true);\r\n\r\n  const onOptionChange = useCallback((option: Option | null): void => {\r\n    const optionJsonStr = JSON.stringify(option || {}).replace(/"/g, "\'");\r\n    renderInfoToast(`Selected Option: ${optionJsonStr}`);\r\n  }, []);\r\n\r\n  const onMenuOpen = useCallback((): void => renderInfoToast(\'Menu opened!\'), []);\r\n  const onMenuClose = useCallback((): void => renderInfoToast(\'Menu closed!\'), []);\r\n  const onInputBlur = useCallback((): void => renderInfoToast(\'Control blurred!\'), []);\r\n  const onInputFocus = useCallback((): void => renderInfoToast(\'Control focused!\'), []);\r\n  const onKeyDown = useCallback((): void => renderInfoToast(\'keydown event executed!\'), []);\r\n\r\n  // Configure reat-toastify onMount and cleanup active toasts on beforeDismount\r\n  useEffect(() => {\r\n    toast.configure(TOAST_CONTAINER_PROPS);\r\n\r\n    return () => {\r\n      toast.dismiss();\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Events</Title>\r\n      <Hr />\r\n      <ListWrapper>\r\n        There are various callback function properties that are executed following\r\n        their associated events:\r\n        <List>\r\n          <Li>\r\n            <TextHeader>onOptionChange(data: any): void</TextHeader> -\r\n            executed after an option is selected or removed\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>onMenuOpen(...args: any[]): void</TextHeader> -\r\n            executed after the menu is opened\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>onMenuClose(...args: any[]): void</TextHeader> -\r\n            executed after the menu is closed\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>onInputChange(value: string): void</TextHeader> -\r\n            executed after the input control\'s value changes\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>onInputBlur(e: FocusEvent&lt;HTMLInputElement&gt;): void</TextHeader> -\r\n            executed after the input control is blurred\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>onInputFocus(e: FocusEvent&lt;HTMLInputElement&gt;): void</TextHeader> -\r\n            executed after the input control is focused\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>onKeyDown(e: KeyboardEvent&lt;HTMLDivElement&gt;, input?: string, focusedOption?: FocusedOption): void</TextHeader> -\r\n            executed after the onKeyDown event\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>onSearchChange(value: string): void</TextHeader> -\r\n            executed after the input value is persisted to state; this value also evaluates\r\n            the <code>inputDelay</code> property for debouncing - this callback is really only\r\n            useful when <code>inputDelay</code> is defined, and if not, it probably makes more\r\n            sense to use the <code>onInputChange</code> callback\r\n          </Li>\r\n        </List>\r\n      </ListWrapper>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Label>Events trigger a toast notification</Label>\r\n          <Checkboxes>\r\n            <Checkbox\r\n              label=\'onOptionChange\'\r\n              checked={addOnOptionChange}\r\n              onCheck={setAddOnOptionChange}\r\n            />\r\n            <Checkbox\r\n              label=\'onMenuOpen\'\r\n              checked={addOnMenuOpen}\r\n              onCheck={setAddOnMenuOpen}\r\n            />\r\n            <Checkbox\r\n              label=\'onMenuClose\'\r\n              checked={addOnMenuClose}\r\n              onCheck={setAddOnMenuClose}\r\n            />\r\n            <Checkbox\r\n              label=\'onInputBlur\'\r\n              checked={addOnInputBlur}\r\n              onCheck={setAddOnInputBlur}\r\n            />\r\n            <Checkbox\r\n              label=\'onInputFocus\'\r\n              checked={addOnInputFocus}\r\n              onCheck={setAddOnInputFocus}\r\n            />\r\n            <Checkbox\r\n              label=\'onKeyDown\'\r\n              checked={addOnKeyDown}\r\n              onCheck={setAddOnKeyDown}\r\n            />\r\n          </Checkboxes>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <SelectContainer>\r\n            <Select\r\n              options={options}\r\n              onKeyDown={addOnKeyDown ? onKeyDown : undefined}\r\n              onMenuOpen={addOnMenuOpen ? onMenuOpen : undefined}\r\n              onMenuClose={addOnMenuClose ? onMenuClose : undefined}\r\n              onInputBlur={addOnInputBlur ? onInputBlur : undefined}\r\n              onInputFocus={addOnInputFocus ? onInputFocus : undefined}\r\n              onOptionChange={addOnOptionChange ? onOptionChange : undefined}\r\n            />\r\n          </SelectContainer>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};;\r\n\r\nexport const Methods = () => {\r\n  const selectRef = useRef<SelectRef | null>(null);\r\n  const options = useMemo<Option[]>(() => createSelectOptions(5), []);\r\n\r\n  const blurSelect = (): void => {\r\n    selectRef.current && selectRef.current.blur();\r\n  };\r\n\r\n  const focusSelect = (): void => {\r\n    selectRef.current && selectRef.current.focus();\r\n  };\r\n\r\n  const clearValue = (): void => {\r\n    selectRef.current && selectRef.current.clearValue();\r\n  };\r\n\r\n  const toggleMenuOpen = (): void => {\r\n    selectRef.current && selectRef.current.toggleMenu(true);\r\n  };\r\n\r\n  const updateSelectedOption = (): void => {\r\n    selectRef.current && selectRef.current.setValue(options[0]);\r\n  };\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Methods</Title>\r\n      <Hr />\r\n      <ListWrapper>\r\n        Five public methods are exposed to wrapping components and are\r\n        accessible via a forwarded <code>ref</code>.\r\n        <List>\r\n          <Li>\r\n            <TextHeader>blur(): void</TextHeader> - blur the control\r\n            programatically\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>focus(): void</TextHeader> - focus the control\r\n            programatically\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>toggleMenu(state?: boolean): void</TextHeader> -\r\n            toggle the menu programatically\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>clearValue(): void</TextHeader> - clear the current\r\n            value programatically <em>(if an option is selected)</em>\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>setValue(option?: any): void</TextHeader> - set the\r\n            value programatically <em>(option will be validated)</em>\r\n          </Li>\r\n        </List>\r\n      </ListWrapper>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Label>Methods</Label>\r\n          <Buttons>\r\n            <Button onClick={focusSelect}>Focus</Button>\r\n            <Button onClick={blurSelect}>Blur</Button>\r\n            <Button onClick={toggleMenuOpen}>Open Menu</Button>\r\n            <Button onClick={clearValue}>Clear Value</Button>\r\n            <Button onClick={updateSelectedOption}>Set Value (1st Option)</Button>\r\n          </Buttons>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <SelectContainer>\r\n            <Select\r\n              ref={selectRef}\r\n              options={options}\r\n              initialValue={options[0]}\r\n            />\r\n          </SelectContainer>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};;\r\n\r\nexport const Filtering = () => {\r\n  const [filterIgnoreCase, setFilterIgnoreCase] = useCallbackState(true);\r\n  const [useCustomFilterFunc, setUseCustomFilterFunc] = useCallbackState(false);\r\n  const [filterIgnoreAccents, setFilterIgnoreAccents] = useCallbackState(false);\r\n  const [filterMatchFromStart, setFilterMatchFromStart] = useCallbackState(false);\r\n\r\n  const getOptionValue = useCallback((option: CityOption): number => option.id, []);\r\n  const getOptionLabel = useCallback((option: CityOption): string => `${option.city}, ${option.state}`, []);\r\n  const getFilterOptionString = useCallback((menuOption: MenuOption): string => menuOption.data.state, []);\r\n\r\n  const options = useMemo<CityOption[]>(() => [...CITY_OPTIONS, { id: 11, city: \'So Paulo\', state: \'BR\' }], []);\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Filter Customization</Title>\r\n      <Hr />\r\n      <ListWrapper>\r\n        The default filtering functionality can be customized via the following properties:\r\n        <List>\r\n          <Li>\r\n            <TextHeader>filterIgnoreCase?: boolean</TextHeader> - Filter ignores\r\n            case when matching strings. Default value is <code>true</code>.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>filterIgnoreAccents?: boolean</TextHeader> - Filter\r\n            ignores accents when matching strings. Default value is <code>false</code>.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>filterMatchFrom?: \'any\' | \'start\'</TextHeader> -\r\n            Position in source string to perform match. Default value is <code>\'any\'</code>.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>getFilterOptionString(option: MenuOption): string</TextHeader> -\r\n            When defined will take each option and generate a string used in\r\n            the filtering process. By default, the stringified version of what is\r\n            generated by <code>getOptionLabel</code>, if definded, or the option\'s label\r\n            as a fallback. The <code>MenuOption</code> typed parameter\r\n            that <code>getFilterOptionString</code> accepts contains a <code>data</code> property\r\n            that represents the objects that comprise your <code>options</code> property.\r\n          </Li>\r\n        </List>\r\n      </ListWrapper>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Checkboxes>\r\n            <Checkbox\r\n              label=\'Ignore Case\'\r\n              checked={filterIgnoreCase}\r\n              onCheck={setFilterIgnoreCase}\r\n            />\r\n            <Checkbox\r\n              label=\'Ignore Accents\'\r\n              checked={filterIgnoreAccents}\r\n              onCheck={setFilterIgnoreAccents}\r\n            />\r\n            <Checkbox\r\n              label=\'Match from the start\'\r\n              checked={filterMatchFromStart}\r\n              onCheck={setFilterMatchFromStart}\r\n            />\r\n            <Checkbox\r\n              label=\'Use custom filter function (by state only)\'\r\n              checked={useCustomFilterFunc}\r\n              onCheck={setUseCustomFilterFunc}\r\n            />\r\n          </Checkboxes>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <SelectContainer>\r\n            <Select\r\n              isClearable\r\n              options={options}\r\n              getOptionValue={getOptionValue}\r\n              getOptionLabel={getOptionLabel}\r\n              filterIgnoreCase={filterIgnoreCase}\r\n              filterIgnoreAccents={filterIgnoreAccents}\r\n              getFilterOptionString={useCustomFilterFunc ? getFilterOptionString : undefined}\r\n              filterMatchFrom={filterMatchFromStart ? FilterMatchEnum.START : FilterMatchEnum.ANY}\r\n            />\r\n          </SelectContainer>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};;\r\n\r\nexport const Windowing = () => {\r\n  const optionCountList: number[] = [100, 1000, 5000, 25000, 50000];\r\n\r\n  const selectRef = useRef<SelectRef | null>(null);\r\n  const [options, setOptions] = useState<Option[]>([]);\r\n  const [optionsCount, setOptionsCount] = useState<number>(optionCountList[0]);\r\n\r\n  useUpdateEffect(() => {\r\n    selectRef.current && selectRef.current.clearValue();\r\n  }, [options]);\r\n\r\n  useEffect(() => {\r\n    const nextSelectOptions = createSelectOptions(optionsCount);\r\n    setOptions(nextSelectOptions);\r\n  }, [optionsCount]);\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Integrated Windowing</Title>\r\n      <Hr />\r\n      <ListWrapper>\r\n        Option data is \'windowed\' using the{\' \'}\r\n        <PackageLink {...REACT_WINDOW_PACKAGE} /> package. Aside from the\r\n        obvious benefits provided by only rendering a small subset of your\r\n        enumerable data (rather than bloating the DOM with an excessive amount\r\n        of nodes), \'windowing\' can also assist with:\r\n        <List>\r\n          <Li>\r\n            <strong>Efficient memory allocation</strong>. \'Windowing\' naturally\r\n            lends itself to the dynamic generation of attributes/values as each\r\n            object comes into your renderer\'s scope (as opposed to allocating\r\n            this data upfront for each object in your list). This way you can\r\n            perform this work just when you absolutely need to and then can\r\n            immediately release it for the GC to cleanup. As an example I am\r\n            generating the <code>onClick</code>, <code>id</code>, and{\' \'}\r\n            <code>className</code> attributes for each <code>menuOption</code>{\' \'}\r\n            as they get passed to the <code>&lt;Option /&gt;</code> renderer\r\n            component.\r\n          </Li>\r\n          <Li>\r\n            <strong>Functional architecture</strong>. The flexibility provided\r\n            through only having to manage subsets of your list allows for a more\r\n            dynamic application. By breaking your code out into smaller, \'pure\'\r\n            child components, you can write code that scales well and becomes\r\n            open to performance optimizations - most notably, memoization.\r\n            Simple components that rely on the props passed to it (rather than\r\n            its own managed state) to generate its JSX are likely candidates for\r\n            memoization (testing &amp; debugging becomes much easier as well).\r\n          </Li>\r\n        </List>\r\n        <em>Note: </em>The only time any noticeable performance degradation will\r\n        be observed is during search input updates when the <code>options</code>{\' \'}\r\n        count reaches the high tens of thousands. To work around this, the{\' \'}\r\n        <code>inputDelay</code> (number in milliseconds) can be set to debounce\r\n        the input value. That way, the <code>menuOptions</code> will not be\r\n        recalculated on every keystroke.\r\n      </ListWrapper>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Label>Options Count</Label>\r\n          <Buttons>\r\n            {optionCountList.map((count) => (\r\n              <OptionsCountButton\r\n                key={count}\r\n                count={count}\r\n                optionsCount={optionsCount}\r\n                setOptionsCount={setOptionsCount}\r\n              />\r\n            ))}\r\n          </Buttons>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <SelectContainer>\r\n            <Select ref={selectRef} options={options} />\r\n          </SelectContainer>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};;\r\n\r\nexport const Advanced = () => {\r\n  const getOptionValue = useCallback((option: PackageOption): number => option.id, []);\r\n  const getIsOptionDisabled = useCallback((option: PackageOption): boolean => (option.name === PACKAGE_OPTIONS[3].name), []);\r\n\r\n  const renderOptionLabel = useCallback(\r\n    (option: PackageOption): ReactNode => (\r\n      <OptionContainer>\r\n        <ReactSvg\r\n          aria-hidden=\'true\'\r\n          viewBox=\'0 0 841.9 595.3\'\r\n          isDisabled={getIsOptionDisabled(option)}\r\n        >\r\n          <path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z" />\r\n          <circle cx="420.9" cy="296.5" r="45.7" />\r\n        </ReactSvg>\r\n        <OptionName>{option.name}</OptionName>\r\n      </OptionContainer>\r\n    ),\r\n    [getIsOptionDisabled]\r\n  );\r\n\r\n  const customCaretIcon = useCallback(\r\n    ({ menuOpen }): ReactNode => (\r\n      <ChevronDownSvg menuOpen={menuOpen} aria-hidden=\'true\' viewBox=\'0 0 448 512\'>\r\n        <path d=\'M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z\' />\r\n      </ChevronDownSvg>\r\n    ),\r\n    []\r\n  );\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Advanced Customization</Title>\r\n      <Hr />\r\n      <ListWrapper>\r\n        Implementation using a couple of the more specialized properties.\r\n        <List>\r\n          <Li>\r\n            <TextHeader>renderOptionLabel(option: any): React.ReactNode</TextHeader> - Callback\r\n            function with a return type of <code>ReactNode</code>. Use this property in cases\r\n            where the standard <code>getOptionLabel</code> property won\'t meet your needs (for\r\n            instance, you want to render each option\'s label using custom JSX). More complex\r\n            option labels will likely equate to longer render durations - this can translate\r\n            into a flash of empty space when a user first starts scrolling. In order to prevent\r\n            this, the <code>menuOverscanCount</code> property can be increased to render additional\r\n            rows outside of the visible area. The default value for this property is 1 and it is\r\n            important to note that increasing this value can negatively impact performance.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>getIsOptionDisabled(option: any): boolean</TextHeader> - Callback\r\n            function with a return type of <code>Boolean</code>. When it evaluates to a value of\r\n            true, that option iteration will be rendered <em>disabled</em>. As an alternative, you\r\n            can also pass a property of <code>isDisabled</code> with each option. Use of these two\r\n            options - they cannot both be specified.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>caretIcon: ReactNode | (...args: any[]) =&gt; ReactNode</TextHeader> - A custom\r\n            node or a function that returns a node can used for the <code>caretIcon</code> property.\r\n            When using a function, an object containing stateful data is forwarded and can be used to style\r\n            your custom node accordingly. The state is <code>{\'{ menuOpen, isLoading, isInvalid, isDisabled }\'}</code> of\r\n            type <code>Record&lt;string, boolean&gt;</code>. The <code>clearIcon</code> property has an identical definition.\r\n          </Li>\r\n        </List>\r\n      </ListWrapper>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Label>JSX labels, custom caret icon, and disabled option</Label>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <SelectContainer>\r\n            <Select\r\n              isSearchable={false}\r\n              options={PACKAGE_OPTIONS}\r\n              themeConfig={THEME_CONFIG}\r\n              caretIcon={customCaretIcon}\r\n              getOptionValue={getOptionValue}\r\n              renderOptionLabel={renderOptionLabel}\r\n              getIsOptionDisabled={getIsOptionDisabled}\r\n            />\r\n          </SelectContainer>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};;\r\n\r\nexport const Async = () => {\r\n  const [isLoading, setIsLoading] = useState<boolean>(false);\r\n  const [options, setOptions] = useState<Option[]>(() => createAsyncOptions(5, \'Initial\'));\r\n\r\n  const onInputChange = useCallback((): void => setIsLoading(true), []);\r\n\r\n  const onSearchChange = useCallback((value?: string): void => {\r\n    mockHttpRequest()\r\n      .then(() => {\r\n        const nextOptions = createAsyncOptions(\r\n          getRandomInt(1, 5),\r\n          `Search text: ${value || \'Initial\'}`\r\n        );\r\n\r\n        setOptions(nextOptions);\r\n      })\r\n      .catch((err) => console.error(err))\r\n      .then(() => setIsLoading(false));\r\n  }, []);\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Async Mode</Title>\r\n      <Hr />\r\n      <ListWrapper>\r\n        Add the <code>async</code> property to enable async mode. There is one key\r\n        difference in core functionality with async mode - changes to search input\r\n        value will not cause the <code>useMenuOptions</code> effect to run. The rest\r\n        of hooking into async mode is achieved using some combination of the properties\r\n        found below. <em>Properties onInputChange and onSearchChange should be memoized.</em>\r\n        <List>\r\n          <Li>\r\n            <TextHeader>onInputChange(value: string): void</TextHeader> -\r\n            callback executed directly following the input control\'s <code>onChange</code> event.\r\n            This callback is not debounced, so it fires immediately. This is a good\r\n            place to set a stateful loading property in your parent component that is mapped to\r\n            react-functional-select\'s <code>isLoading</code> property.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>onSearchChange(value: string): void</TextHeader> -\r\n            callback executed following component state updates for\r\n            the <code>debouncedInputValue</code>. The debounce is set using\r\n            the <code>inputDelay</code> property. This callback is a good place for your\r\n            http fetch request and post-request logic (i.e. setting isLoading false).\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>inputDelay?: number</TextHeader> - As mentioned above, this can be\r\n            set to a positive integer in order to debounce updates to the search input value\r\n            following input change events. This property directly maps to the <code>delay</code> in\r\n            milliconds passed to the <code>setTimeout</code> method.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>isLoading?: boolean</TextHeader> - When true, a loading animation will\r\n            appear in the far-right of the control and take the place of the clear icon (if shown).\r\n            Additionally, it will hide options in the menu and instead, display a loading message.\r\n            The loading message text defaults to \'Loading...\', but can be overriden via\r\n            the <code>loadingMsg</code> property.\r\n          </Li>\r\n        </List>\r\n      </ListWrapper>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Label>Search debounced 500ms and mock HTTP call resolves after 500ms</Label>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <SelectContainer>\r\n            <Select\r\n              async\r\n              isClearable\r\n              inputDelay={500}\r\n              options={options}\r\n              isLoading={isLoading}\r\n              onInputChange={onInputChange}\r\n              onSearchChange={onSearchChange}\r\n            />\r\n          </SelectContainer>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};\n',locationsMap:{"single-select":{startLoc:{col:28,line:86},endLoc:{col:1,line:171},startBody:{col:28,line:86},endBody:{col:1,line:171}},"multi-select":{startLoc:{col:27,line:173},endLoc:{col:1,line:285},startBody:{col:27,line:173},endBody:{col:1,line:285}},styling:{startLoc:{col:23,line:287},endLoc:{col:1,line:403},startBody:{col:23,line:287},endBody:{col:1,line:403}},events:{startLoc:{col:22,line:405},endLoc:{col:1,line:534},startBody:{col:22,line:405},endBody:{col:1,line:534}},methods:{startLoc:{col:23,line:536},endLoc:{col:1,line:615},startBody:{col:23,line:536},endBody:{col:1,line:615}},filtering:{startLoc:{col:25,line:617},endLoc:{col:1,line:703},startBody:{col:25,line:617},endBody:{col:1,line:703}},windowing:{startLoc:{col:25,line:705},endLoc:{col:1,line:786},startBody:{col:25,line:705},endBody:{col:1,line:786}},advanced:{startLoc:{col:24,line:788},endLoc:{col:1,line:874},startBody:{col:24,line:788},endBody:{col:1,line:874}},async:{startLoc:{col:21,line:876},endLoc:{col:1,line:958},startBody:{col:21,line:876},endBody:{col:1,line:958}}}}},"storySource",{source:"import { useMemo, useRef, useState, useEffect, useCallback, Fragment, ReactNode } from 'react';\r\nimport { toast } from 'react-toastify';\r\nimport { SelectedOption } from '../src/types';\r\nimport { useUpdateEffect } from '../src/hooks';\r\nimport { useCallbackState } from './helpers/hooks';\r\nimport { CityOption, Option, PackageOption } from './helpers/types';\r\nimport { Select, MultiParams, MenuOption, SelectRef, FilterMatchEnum, Theme } from '../src';\r\nimport { Checkbox, CodeMarkup, PackageLink, OptionsCountButton } from './helpers/components';\r\n\r\nimport {\r\n  mockHttpRequest,\r\n  getRandomInt,\r\n  createAsyncOptions,\r\n  createSelectOptions,\r\n  stringifyJavaScriptObj,\r\n  renderInfoToast\r\n} from './helpers/utils';\r\n\r\nimport {\r\n  ThemeEnum,\r\n  ThemeConfigMap,\r\n  THEME_DEFAULTS,\r\n  THEME_OPTIONS,\r\n  THEME_CONFIG,\r\n  CITY_OPTIONS,\r\n  PACKAGE_OPTIONS,\r\n  CLASS_NAME_HTML,\r\n  REACT_WINDOW_PACKAGE,\r\n  TOAST_CONTAINER_PROPS,\r\n  STYLED_COMPONENTS_PACKAGE\r\n} from './helpers/constants';\r\n\r\nimport {\r\n  OPTION_CLS,\r\n  OPTION_FOCUSED_CLS,\r\n  OPTION_DISABLED_CLS,\r\n  OPTION_SELECTED_CLS,\r\n  CARET_ICON_CLS,\r\n  CLEAR_ICON_CLS,\r\n  LOADING_DOTS_CLS,\r\n  AUTOSIZE_INPUT_CLS,\r\n  MENU_CONTAINER_CLS,\r\n  SELECT_CONTAINER_CLS,\r\n  CONTROL_CONTAINER_CLS,\r\n} from '../src/constants/dom';\r\n\r\nimport {\r\n  Button,\r\n  Buttons,\r\n  Hr,\r\n  Title,\r\n  SubTitle,\r\n  Label,\r\n  Columns,\r\n  Column,\r\n  Content,\r\n  Container,\r\n  List,\r\n  Li,\r\n  ListWrapper,\r\n  SelectContainer,\r\n  Paragraph,\r\n  TextHeader,\r\n  Checkboxes,\r\n  Card,\r\n  CardHeader,\r\n  CardBody,\r\n  OtherSpan,\r\n  OptionContainer,\r\n  OptionName,\r\n  ReactSvg,\r\n  ChevronDownSvg\r\n} from './helpers/styled';\r\n\r\nexport default {\r\n  title: 'React Functional Select'\r\n};\r\n\r\nexport const SingleSelect = () => {\r\n  const [isInvalid, setIsInvalid] = useCallbackState(false);\r\n  const [isLoading, setIsLoading] = useCallbackState(false);\r\n  const [isDisabled, setIsDisabled] = useCallbackState(false);\r\n  const [isClearable, setIsClearable] = useCallbackState(true);\r\n  const [isSearchable, setIsSearchable] = useCallbackState(true);\r\n\r\n  const getOptionValue = useCallback((option: CityOption): number => option.id, []);\r\n  const getOptionLabel = useCallback((option: CityOption): string => `${option.city}, ${option.state}`, []);\r\n\r\n  useEffect(() => {\r\n    isDisabled && setIsInvalid(false);\r\n  }, [isDisabled]);\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Single-select</Title>\r\n      <Hr />\r\n      <Paragraph>\r\n        In this story's source code, notice that the callback function\r\n        properties <code>getOptionValue</code> and <code>getOptionLabel</code> are\r\n        wrapped in a <code>useCallback</code>. While not required, <em> strongly prefer </em>\r\n        memoization of any callback function property whenever possible. This will boost\r\n        performance and reduce the amount of renders as these properties are referenced\r\n        in the dependency arrays of <code>useCallbacks</code>, <code>useEffects</code>,\r\n        and <code>useMemos</code>. When defined in a functional component, wrap in\r\n        a <code>useCallback</code>; when defined in a legacy class component, ensure proper\r\n        binding to <code>this</code>. Alternatively, if there is no dependency on any state,\r\n        you can opt to hoist functions outside of the component entirely.\r\n      </Paragraph>\r\n      <Paragraph>\r\n        The <code>options</code> property should also be memoized. Either consume\r\n        it directly from a state management store, or make sure it is stable by\r\n        avoiding inline or render-based mutations.\r\n      </Paragraph>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Checkboxes>\r\n            <Checkbox\r\n              label='Searchable'\r\n              checked={isSearchable}\r\n              onCheck={setIsSearchable}\r\n            />\r\n            <Checkbox\r\n              label='Clearable'\r\n              checked={isClearable}\r\n              onCheck={setIsClearable}\r\n            />\r\n            <Checkbox\r\n              label='Disabled'\r\n              checked={isDisabled}\r\n              onCheck={setIsDisabled}\r\n            />\r\n            <Checkbox\r\n              label='Invalid'\r\n              checked={isInvalid}\r\n              readOnly={isDisabled}\r\n              onCheck={setIsInvalid}\r\n            />\r\n            <Checkbox\r\n              label='Loading'\r\n              checked={isLoading}\r\n              onCheck={setIsLoading}\r\n            />\r\n          </Checkboxes>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <SelectContainer>\r\n            <Select\r\n              isLoading={isLoading}\r\n              isInvalid={isInvalid}\r\n              options={CITY_OPTIONS}\r\n              isDisabled={isDisabled}\r\n              isClearable={isClearable}\r\n              isSearchable={isSearchable}\r\n              getOptionValue={getOptionValue}\r\n              getOptionLabel={getOptionLabel}\r\n            />\r\n          </SelectContainer>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};\r\n\r\nexport const MultiSelect = () => {\r\n  const [openMenuOnClick, setOpenMenuOnClick] = useCallbackState(true);\r\n  const [closeMenuOnSelect, setCloseMenuOnSelect] = useCallbackState(true);\r\n  const [blurInputOnSelect, setBlurInputOnSelect] = useCallbackState(false);\r\n  const [hideSelectedOptions, setHideSelectedOptions] = useCallbackState(true);\r\n  const [useRenderMultiOptions, setUseRenderMultiOptions] = useCallbackState(false);\r\n\r\n  const getOptionValue = useCallback((option: CityOption): number => option.id, []);\r\n  const getOptionLabel = useCallback((option: CityOption): string => `${option.city}, ${option.state}`, []);\r\n\r\n  // Example \"renderMultiOptions\" property that can be used to further customize labeling for multi-option scenarios\r\n  const renderMultiOptions = useCallback(\r\n    ({ selected, renderOptionLabel }: MultiParams): ReactNode => (\r\n      <Fragment>\r\n        {selected.length && renderOptionLabel(selected[0].data)}\r\n        {selected.length > 1 && (\r\n          <OtherSpan>\r\n            {`(+${selected.length - 1} ${selected.length === 2 ? 'other' : 'others'})`}\r\n          </OtherSpan>\r\n        )}\r\n      </Fragment>\r\n    ),\r\n    []\r\n  );\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Multi-select</Title>\r\n      <Hr />\r\n      <ListWrapper>\r\n        Add the <code>isMulti</code> property to allow for multiple selections.\r\n        While in multi-select mode, some properties are now applicable and\r\n        others become more pertinent.\r\n        <List>\r\n          <Li>\r\n            <TextHeader>hideSelectedOptions?: boolean</TextHeader> - Hide the\r\n            selected option from the menu. Default value is false, however, if\r\n            undefined and <code>isMulti === true</code>, then its value defaults\r\n            to true.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>closeMenuOnSelect?: boolean</TextHeader> - Close the\r\n            menu of options when the user selects an option. Default value is\r\n            false, however, it may be benefical to set this property to true for\r\n            convenience in multi-select scenarios.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>renderMultiOptions(params: MultiParams): ReactNode</TextHeader> -\r\n            Optional callback function that can be used to further customize the selection label\r\n            in multi-select scenarios. <code>params</code> is an object that contains\r\n            the <code>selected</code> and <code>renderOptionLabel</code> properties (array\r\n            of selected options and function used to render individual option labels, respectively).\r\n            When this function is defined, left and right arrow navigation of individual options is\r\n            disabled. When using this property, it may be be a good idea to set the\r\n            property <code>backspaceClearsValue</code> to <em>false</em> in order to avoid accidentally\r\n            clearing all selections when searching.\r\n          </Li>\r\n        </List>\r\n      </ListWrapper>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Checkboxes>\r\n            <Checkbox\r\n              label='closeMenuOnSelect'\r\n              checked={closeMenuOnSelect}\r\n              onCheck={setCloseMenuOnSelect}\r\n            />\r\n            <Checkbox\r\n              label='hideSelectedOptions'\r\n              checked={hideSelectedOptions}\r\n              onCheck={setHideSelectedOptions}\r\n            />\r\n            <Checkbox\r\n              label='blurInputOnSelect'\r\n              checked={blurInputOnSelect}\r\n              onCheck={setBlurInputOnSelect}\r\n            />\r\n            <Checkbox\r\n              label='openMenuOnClick (click caret if false)'\r\n              checked={openMenuOnClick}\r\n              onCheck={setOpenMenuOnClick}\r\n            />\r\n            <Checkbox\r\n              label='renderMultiOptions (custom renderer)'\r\n              checked={useRenderMultiOptions}\r\n              onCheck={setUseRenderMultiOptions}\r\n            />\r\n          </Checkboxes>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <SelectContainer>\r\n            <Select\r\n              isMulti\r\n              isClearable\r\n              isSearchable\r\n              options={CITY_OPTIONS}\r\n              getOptionValue={getOptionValue}\r\n              getOptionLabel={getOptionLabel}\r\n              openMenuOnClick={openMenuOnClick}\r\n              blurInputOnSelect={blurInputOnSelect}\r\n              closeMenuOnSelect={closeMenuOnSelect}\r\n              hideSelectedOptions={hideSelectedOptions}\r\n              backspaceClearsValue={!useRenderMultiOptions}\r\n              renderMultiOptions={useRenderMultiOptions ? renderMultiOptions : undefined}\r\n            />\r\n          </SelectContainer>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};\r\n\r\nexport const Styling = () => {\r\n  const [themeConfig, setThemeConfig] = useState<Theme>();\r\n  const [selectedOption, setSelectedOption] = useCallbackState<SelectedOption | null>(null);\r\n  const menuItemSize = (selectedOption && selectedOption.value === ThemeEnum.LARGE_TEXT) ? 44 : 35;\r\n\r\n  const memoizedMarkupNode = useMemo<ReactNode>(() => (\r\n    <CodeMarkup\r\n      language='markup'\r\n      header='Class Markup'\r\n      data={CLASS_NAME_HTML}\r\n    />\r\n  ), []);\r\n\r\n  useEffect(() => {\r\n    if (selectedOption) {\r\n      const { value } = selectedOption;\r\n      setThemeConfig(ThemeConfigMap[value]);\r\n    }\r\n  }, [selectedOption]);\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Styling</Title>\r\n      <Hr />\r\n      <SubTitle>Theming</SubTitle>\r\n      <Columns>\r\n        <Column widthPercent={40}>\r\n          <Content>\r\n            react-functional-select uses <PackageLink {...STYLED_COMPONENTS_PACKAGE} /> to\r\n            handle its styling. The root node is wrapped in\r\n            styled-component's <code>ThemeProvider</code> wrapper component which gives all\r\n            child styled-components access to the provided theme via React's context API.\r\n            To override react-functional-select's default theme, pass an object to\r\n            the <code>themeConfig</code> property - any matching properties will replace\r\n            those in the default theme.\r\n          </Content>\r\n          <Content>\r\n            Starting in <strong>v2.0.0</strong>, some of the nested objects in\r\n            the <code>themeConfig</code> object contain a <code>css</code> property\r\n            of type <code>string | FlattenSimpleInterpolation | undefined</code> (default value\r\n            is undefined). This property can be used to pass raw CSS styles as a string or wrapped\r\n            in <PackageLink {...STYLED_COMPONENTS_PACKAGE} /> exported <code>css</code> function.\r\n            Those objects are: select, control, icon, menu, noOptions, multiValue, and input.\r\n          </Content>\r\n          <Content>\r\n            Starting in <strong>v2.7.0</strong>, the control object in <code>themeConfig</code> has\r\n            the property <code>focusedCss</code> - which is similar to the <code>css</code> property,\r\n            except that it is only applied when the select control is focused (and removed when blurred).\r\n          </Content>\r\n        </Column>\r\n        <Column widthPercent={60}>\r\n          <CodeMarkup\r\n            language='javascript'\r\n            data={THEME_DEFAULTS}\r\n            header='Theme Defaults'\r\n            formatFn={stringifyJavaScriptObj}\r\n          />\r\n        </Column>\r\n      </Columns>\r\n      <SubTitle>Using Classes</SubTitle>\r\n      <Columns>\r\n        <Column widthPercent={40}>\r\n          <Content>\r\n            If you want to style the component using CSS classes, set the <code>addClassNames</code> prop\r\n            to true and it will then generate <code>className</code> attributes for that specific instance\r\n            of the component. These are the classes that are available:\r\n          </Content>\r\n          <ListWrapper className='is-class-list'>\r\n            <List>\r\n              <Li>{SELECT_CONTAINER_CLS}</Li>\r\n              <Li>{CONTROL_CONTAINER_CLS}</Li>\r\n              <Li>{MENU_CONTAINER_CLS}</Li>\r\n              <Li>{AUTOSIZE_INPUT_CLS}</Li>\r\n              <Li>{CARET_ICON_CLS}</Li>\r\n              <Li>{CLEAR_ICON_CLS}</Li>\r\n              <Li>{LOADING_DOTS_CLS}</Li>\r\n              <Li>{`${OPTION_CLS}, ${OPTION_FOCUSED_CLS}, ${OPTION_SELECTED_CLS}, ${OPTION_DISABLED_CLS}`}</Li>\r\n            </List>\r\n          </ListWrapper>\r\n        </Column>\r\n        <Column widthPercent={60}>{memoizedMarkupNode}</Column>\r\n      </Columns>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Label>Try selecting different themes</Label>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <Columns>\r\n            <Column widthPercent={40}>\r\n              <div style={{ marginTop: '1rem' }}>\r\n                <Select\r\n                  isClearable={false}\r\n                  isSearchable={false}\r\n                  options={THEME_OPTIONS}\r\n                  themeConfig={themeConfig}\r\n                  menuItemSize={menuItemSize}\r\n                  initialValue={THEME_OPTIONS[0]}\r\n                  onOptionChange={setSelectedOption}\r\n                />\r\n              </div>\r\n            </Column>\r\n            <Column widthPercent={60}>\r\n              <CodeMarkup\r\n                data={themeConfig}\r\n                language='javascript'\r\n                header='theme-config'\r\n                formatFn={stringifyJavaScriptObj}\r\n              />\r\n            </Column>\r\n          </Columns>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};\r\n\r\nexport const Events = () => {\r\n  const options = useMemo<Option[]>(() => createSelectOptions(5), []);\r\n\r\n  const [addOnKeyDown, setAddOnKeyDown] = useCallbackState(false);\r\n  const [addOnMenuOpen, setAddOnMenuOpen] = useCallbackState(true);\r\n  const [addOnMenuClose, setAddOnMenuClose] = useCallbackState(false);\r\n  const [addOnInputBlur, setAddOnInputBlur] = useCallbackState(false);\r\n  const [addOnInputFocus, setAddOnInputFocus] = useCallbackState(false);\r\n  const [addOnOptionChange, setAddOnOptionChange] = useCallbackState(true);\r\n\r\n  const onOptionChange = useCallback((option: Option | null): void => {\r\n    const optionJsonStr = JSON.stringify(option || {}).replace(/\"/g, \"'\");\r\n    renderInfoToast(`Selected Option: ${optionJsonStr}`);\r\n  }, []);\r\n\r\n  const onMenuOpen = useCallback((): void => renderInfoToast('Menu opened!'), []);\r\n  const onMenuClose = useCallback((): void => renderInfoToast('Menu closed!'), []);\r\n  const onInputBlur = useCallback((): void => renderInfoToast('Control blurred!'), []);\r\n  const onInputFocus = useCallback((): void => renderInfoToast('Control focused!'), []);\r\n  const onKeyDown = useCallback((): void => renderInfoToast('keydown event executed!'), []);\r\n\r\n  // Configure reat-toastify onMount and cleanup active toasts on beforeDismount\r\n  useEffect(() => {\r\n    toast.configure(TOAST_CONTAINER_PROPS);\r\n\r\n    return () => {\r\n      toast.dismiss();\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Events</Title>\r\n      <Hr />\r\n      <ListWrapper>\r\n        There are various callback function properties that are executed following\r\n        their associated events:\r\n        <List>\r\n          <Li>\r\n            <TextHeader>onOptionChange(data: any): void</TextHeader> -\r\n            executed after an option is selected or removed\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>onMenuOpen(...args: any[]): void</TextHeader> -\r\n            executed after the menu is opened\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>onMenuClose(...args: any[]): void</TextHeader> -\r\n            executed after the menu is closed\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>onInputChange(value: string): void</TextHeader> -\r\n            executed after the input control's value changes\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>onInputBlur(e: FocusEvent&lt;HTMLInputElement&gt;): void</TextHeader> -\r\n            executed after the input control is blurred\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>onInputFocus(e: FocusEvent&lt;HTMLInputElement&gt;): void</TextHeader> -\r\n            executed after the input control is focused\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>onKeyDown(e: KeyboardEvent&lt;HTMLDivElement&gt;, input?: string, focusedOption?: FocusedOption): void</TextHeader> -\r\n            executed after the onKeyDown event\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>onSearchChange(value: string): void</TextHeader> -\r\n            executed after the input value is persisted to state; this value also evaluates\r\n            the <code>inputDelay</code> property for debouncing - this callback is really only\r\n            useful when <code>inputDelay</code> is defined, and if not, it probably makes more\r\n            sense to use the <code>onInputChange</code> callback\r\n          </Li>\r\n        </List>\r\n      </ListWrapper>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Label>Events trigger a toast notification</Label>\r\n          <Checkboxes>\r\n            <Checkbox\r\n              label='onOptionChange'\r\n              checked={addOnOptionChange}\r\n              onCheck={setAddOnOptionChange}\r\n            />\r\n            <Checkbox\r\n              label='onMenuOpen'\r\n              checked={addOnMenuOpen}\r\n              onCheck={setAddOnMenuOpen}\r\n            />\r\n            <Checkbox\r\n              label='onMenuClose'\r\n              checked={addOnMenuClose}\r\n              onCheck={setAddOnMenuClose}\r\n            />\r\n            <Checkbox\r\n              label='onInputBlur'\r\n              checked={addOnInputBlur}\r\n              onCheck={setAddOnInputBlur}\r\n            />\r\n            <Checkbox\r\n              label='onInputFocus'\r\n              checked={addOnInputFocus}\r\n              onCheck={setAddOnInputFocus}\r\n            />\r\n            <Checkbox\r\n              label='onKeyDown'\r\n              checked={addOnKeyDown}\r\n              onCheck={setAddOnKeyDown}\r\n            />\r\n          </Checkboxes>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <SelectContainer>\r\n            <Select\r\n              options={options}\r\n              onKeyDown={addOnKeyDown ? onKeyDown : undefined}\r\n              onMenuOpen={addOnMenuOpen ? onMenuOpen : undefined}\r\n              onMenuClose={addOnMenuClose ? onMenuClose : undefined}\r\n              onInputBlur={addOnInputBlur ? onInputBlur : undefined}\r\n              onInputFocus={addOnInputFocus ? onInputFocus : undefined}\r\n              onOptionChange={addOnOptionChange ? onOptionChange : undefined}\r\n            />\r\n          </SelectContainer>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};\r\n\r\nexport const Methods = () => {\r\n  const selectRef = useRef<SelectRef | null>(null);\r\n  const options = useMemo<Option[]>(() => createSelectOptions(5), []);\r\n\r\n  const blurSelect = (): void => {\r\n    selectRef.current && selectRef.current.blur();\r\n  };\r\n\r\n  const focusSelect = (): void => {\r\n    selectRef.current && selectRef.current.focus();\r\n  };\r\n\r\n  const clearValue = (): void => {\r\n    selectRef.current && selectRef.current.clearValue();\r\n  };\r\n\r\n  const toggleMenuOpen = (): void => {\r\n    selectRef.current && selectRef.current.toggleMenu(true);\r\n  };\r\n\r\n  const updateSelectedOption = (): void => {\r\n    selectRef.current && selectRef.current.setValue(options[0]);\r\n  };\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Methods</Title>\r\n      <Hr />\r\n      <ListWrapper>\r\n        Five public methods are exposed to wrapping components and are\r\n        accessible via a forwarded <code>ref</code>.\r\n        <List>\r\n          <Li>\r\n            <TextHeader>blur(): void</TextHeader> - blur the control\r\n            programatically\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>focus(): void</TextHeader> - focus the control\r\n            programatically\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>toggleMenu(state?: boolean): void</TextHeader> -\r\n            toggle the menu programatically\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>clearValue(): void</TextHeader> - clear the current\r\n            value programatically <em>(if an option is selected)</em>\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>setValue(option?: any): void</TextHeader> - set the\r\n            value programatically <em>(option will be validated)</em>\r\n          </Li>\r\n        </List>\r\n      </ListWrapper>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Label>Methods</Label>\r\n          <Buttons>\r\n            <Button onClick={focusSelect}>Focus</Button>\r\n            <Button onClick={blurSelect}>Blur</Button>\r\n            <Button onClick={toggleMenuOpen}>Open Menu</Button>\r\n            <Button onClick={clearValue}>Clear Value</Button>\r\n            <Button onClick={updateSelectedOption}>Set Value (1st Option)</Button>\r\n          </Buttons>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <SelectContainer>\r\n            <Select\r\n              ref={selectRef}\r\n              options={options}\r\n              initialValue={options[0]}\r\n            />\r\n          </SelectContainer>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};\r\n\r\nexport const Filtering = () => {\r\n  const [filterIgnoreCase, setFilterIgnoreCase] = useCallbackState(true);\r\n  const [useCustomFilterFunc, setUseCustomFilterFunc] = useCallbackState(false);\r\n  const [filterIgnoreAccents, setFilterIgnoreAccents] = useCallbackState(false);\r\n  const [filterMatchFromStart, setFilterMatchFromStart] = useCallbackState(false);\r\n\r\n  const getOptionValue = useCallback((option: CityOption): number => option.id, []);\r\n  const getOptionLabel = useCallback((option: CityOption): string => `${option.city}, ${option.state}`, []);\r\n  const getFilterOptionString = useCallback((menuOption: MenuOption): string => menuOption.data.state, []);\r\n\r\n  const options = useMemo<CityOption[]>(() => [...CITY_OPTIONS, { id: 11, city: 'So Paulo', state: 'BR' }], []);\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Filter Customization</Title>\r\n      <Hr />\r\n      <ListWrapper>\r\n        The default filtering functionality can be customized via the following properties:\r\n        <List>\r\n          <Li>\r\n            <TextHeader>filterIgnoreCase?: boolean</TextHeader> - Filter ignores\r\n            case when matching strings. Default value is <code>true</code>.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>filterIgnoreAccents?: boolean</TextHeader> - Filter\r\n            ignores accents when matching strings. Default value is <code>false</code>.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>filterMatchFrom?: 'any' | 'start'</TextHeader> -\r\n            Position in source string to perform match. Default value is <code>'any'</code>.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>getFilterOptionString(option: MenuOption): string</TextHeader> -\r\n            When defined will take each option and generate a string used in\r\n            the filtering process. By default, the stringified version of what is\r\n            generated by <code>getOptionLabel</code>, if definded, or the option's label\r\n            as a fallback. The <code>MenuOption</code> typed parameter\r\n            that <code>getFilterOptionString</code> accepts contains a <code>data</code> property\r\n            that represents the objects that comprise your <code>options</code> property.\r\n          </Li>\r\n        </List>\r\n      </ListWrapper>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Checkboxes>\r\n            <Checkbox\r\n              label='Ignore Case'\r\n              checked={filterIgnoreCase}\r\n              onCheck={setFilterIgnoreCase}\r\n            />\r\n            <Checkbox\r\n              label='Ignore Accents'\r\n              checked={filterIgnoreAccents}\r\n              onCheck={setFilterIgnoreAccents}\r\n            />\r\n            <Checkbox\r\n              label='Match from the start'\r\n              checked={filterMatchFromStart}\r\n              onCheck={setFilterMatchFromStart}\r\n            />\r\n            <Checkbox\r\n              label='Use custom filter function (by state only)'\r\n              checked={useCustomFilterFunc}\r\n              onCheck={setUseCustomFilterFunc}\r\n            />\r\n          </Checkboxes>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <SelectContainer>\r\n            <Select\r\n              isClearable\r\n              options={options}\r\n              getOptionValue={getOptionValue}\r\n              getOptionLabel={getOptionLabel}\r\n              filterIgnoreCase={filterIgnoreCase}\r\n              filterIgnoreAccents={filterIgnoreAccents}\r\n              getFilterOptionString={useCustomFilterFunc ? getFilterOptionString : undefined}\r\n              filterMatchFrom={filterMatchFromStart ? FilterMatchEnum.START : FilterMatchEnum.ANY}\r\n            />\r\n          </SelectContainer>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};\r\n\r\nexport const Windowing = () => {\r\n  const optionCountList: number[] = [100, 1000, 5000, 25000, 50000];\r\n\r\n  const selectRef = useRef<SelectRef | null>(null);\r\n  const [options, setOptions] = useState<Option[]>([]);\r\n  const [optionsCount, setOptionsCount] = useState<number>(optionCountList[0]);\r\n\r\n  useUpdateEffect(() => {\r\n    selectRef.current && selectRef.current.clearValue();\r\n  }, [options]);\r\n\r\n  useEffect(() => {\r\n    const nextSelectOptions = createSelectOptions(optionsCount);\r\n    setOptions(nextSelectOptions);\r\n  }, [optionsCount]);\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Integrated Windowing</Title>\r\n      <Hr />\r\n      <ListWrapper>\r\n        Option data is 'windowed' using the{' '}\r\n        <PackageLink {...REACT_WINDOW_PACKAGE} /> package. Aside from the\r\n        obvious benefits provided by only rendering a small subset of your\r\n        enumerable data (rather than bloating the DOM with an excessive amount\r\n        of nodes), 'windowing' can also assist with:\r\n        <List>\r\n          <Li>\r\n            <strong>Efficient memory allocation</strong>. 'Windowing' naturally\r\n            lends itself to the dynamic generation of attributes/values as each\r\n            object comes into your renderer's scope (as opposed to allocating\r\n            this data upfront for each object in your list). This way you can\r\n            perform this work just when you absolutely need to and then can\r\n            immediately release it for the GC to cleanup. As an example I am\r\n            generating the <code>onClick</code>, <code>id</code>, and{' '}\r\n            <code>className</code> attributes for each <code>menuOption</code>{' '}\r\n            as they get passed to the <code>&lt;Option /&gt;</code> renderer\r\n            component.\r\n          </Li>\r\n          <Li>\r\n            <strong>Functional architecture</strong>. The flexibility provided\r\n            through only having to manage subsets of your list allows for a more\r\n            dynamic application. By breaking your code out into smaller, 'pure'\r\n            child components, you can write code that scales well and becomes\r\n            open to performance optimizations - most notably, memoization.\r\n            Simple components that rely on the props passed to it (rather than\r\n            its own managed state) to generate its JSX are likely candidates for\r\n            memoization (testing &amp; debugging becomes much easier as well).\r\n          </Li>\r\n        </List>\r\n        <em>Note: </em>The only time any noticeable performance degradation will\r\n        be observed is during search input updates when the <code>options</code>{' '}\r\n        count reaches the high tens of thousands. To work around this, the{' '}\r\n        <code>inputDelay</code> (number in milliseconds) can be set to debounce\r\n        the input value. That way, the <code>menuOptions</code> will not be\r\n        recalculated on every keystroke.\r\n      </ListWrapper>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Label>Options Count</Label>\r\n          <Buttons>\r\n            {optionCountList.map((count) => (\r\n              <OptionsCountButton\r\n                key={count}\r\n                count={count}\r\n                optionsCount={optionsCount}\r\n                setOptionsCount={setOptionsCount}\r\n              />\r\n            ))}\r\n          </Buttons>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <SelectContainer>\r\n            <Select ref={selectRef} options={options} />\r\n          </SelectContainer>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};\r\n\r\nexport const Advanced = () => {\r\n  const getOptionValue = useCallback((option: PackageOption): number => option.id, []);\r\n  const getIsOptionDisabled = useCallback((option: PackageOption): boolean => (option.name === PACKAGE_OPTIONS[3].name), []);\r\n\r\n  const renderOptionLabel = useCallback(\r\n    (option: PackageOption): ReactNode => (\r\n      <OptionContainer>\r\n        <ReactSvg\r\n          aria-hidden='true'\r\n          viewBox='0 0 841.9 595.3'\r\n          isDisabled={getIsOptionDisabled(option)}\r\n        >\r\n          <path d=\"M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z\" />\r\n          <circle cx=\"420.9\" cy=\"296.5\" r=\"45.7\" />\r\n        </ReactSvg>\r\n        <OptionName>{option.name}</OptionName>\r\n      </OptionContainer>\r\n    ),\r\n    [getIsOptionDisabled]\r\n  );\r\n\r\n  const customCaretIcon = useCallback(\r\n    ({ menuOpen }): ReactNode => (\r\n      <ChevronDownSvg menuOpen={menuOpen} aria-hidden='true' viewBox='0 0 448 512'>\r\n        <path d='M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z' />\r\n      </ChevronDownSvg>\r\n    ),\r\n    []\r\n  );\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Advanced Customization</Title>\r\n      <Hr />\r\n      <ListWrapper>\r\n        Implementation using a couple of the more specialized properties.\r\n        <List>\r\n          <Li>\r\n            <TextHeader>renderOptionLabel(option: any): React.ReactNode</TextHeader> - Callback\r\n            function with a return type of <code>ReactNode</code>. Use this property in cases\r\n            where the standard <code>getOptionLabel</code> property won't meet your needs (for\r\n            instance, you want to render each option's label using custom JSX). More complex\r\n            option labels will likely equate to longer render durations - this can translate\r\n            into a flash of empty space when a user first starts scrolling. In order to prevent\r\n            this, the <code>menuOverscanCount</code> property can be increased to render additional\r\n            rows outside of the visible area. The default value for this property is 1 and it is\r\n            important to note that increasing this value can negatively impact performance.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>getIsOptionDisabled(option: any): boolean</TextHeader> - Callback\r\n            function with a return type of <code>Boolean</code>. When it evaluates to a value of\r\n            true, that option iteration will be rendered <em>disabled</em>. As an alternative, you\r\n            can also pass a property of <code>isDisabled</code> with each option. Use of these two\r\n            options - they cannot both be specified.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>caretIcon: ReactNode | (...args: any[]) =&gt; ReactNode</TextHeader> - A custom\r\n            node or a function that returns a node can used for the <code>caretIcon</code> property.\r\n            When using a function, an object containing stateful data is forwarded and can be used to style\r\n            your custom node accordingly. The state is <code>{'{ menuOpen, isLoading, isInvalid, isDisabled }'}</code> of\r\n            type <code>Record&lt;string, boolean&gt;</code>. The <code>clearIcon</code> property has an identical definition.\r\n          </Li>\r\n        </List>\r\n      </ListWrapper>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Label>JSX labels, custom caret icon, and disabled option</Label>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <SelectContainer>\r\n            <Select\r\n              isSearchable={false}\r\n              options={PACKAGE_OPTIONS}\r\n              themeConfig={THEME_CONFIG}\r\n              caretIcon={customCaretIcon}\r\n              getOptionValue={getOptionValue}\r\n              renderOptionLabel={renderOptionLabel}\r\n              getIsOptionDisabled={getIsOptionDisabled}\r\n            />\r\n          </SelectContainer>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};\r\n\r\nexport const Async = () => {\r\n  const [isLoading, setIsLoading] = useState<boolean>(false);\r\n  const [options, setOptions] = useState<Option[]>(() => createAsyncOptions(5, 'Initial'));\r\n\r\n  const onInputChange = useCallback((): void => setIsLoading(true), []);\r\n\r\n  const onSearchChange = useCallback((value?: string): void => {\r\n    mockHttpRequest()\r\n      .then(() => {\r\n        const nextOptions = createAsyncOptions(\r\n          getRandomInt(1, 5),\r\n          `Search text: ${value || 'Initial'}`\r\n        );\r\n\r\n        setOptions(nextOptions);\r\n      })\r\n      .catch((err) => console.error(err))\r\n      .then(() => setIsLoading(false));\r\n  }, []);\r\n\r\n  return (\r\n    <Container>\r\n      <Title>Async Mode</Title>\r\n      <Hr />\r\n      <ListWrapper>\r\n        Add the <code>async</code> property to enable async mode. There is one key\r\n        difference in core functionality with async mode - changes to search input\r\n        value will not cause the <code>useMenuOptions</code> effect to run. The rest\r\n        of hooking into async mode is achieved using some combination of the properties\r\n        found below. <em>Properties onInputChange and onSearchChange should be memoized.</em>\r\n        <List>\r\n          <Li>\r\n            <TextHeader>onInputChange(value: string): void</TextHeader> -\r\n            callback executed directly following the input control's <code>onChange</code> event.\r\n            This callback is not debounced, so it fires immediately. This is a good\r\n            place to set a stateful loading property in your parent component that is mapped to\r\n            react-functional-select's <code>isLoading</code> property.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>onSearchChange(value: string): void</TextHeader> -\r\n            callback executed following component state updates for\r\n            the <code>debouncedInputValue</code>. The debounce is set using\r\n            the <code>inputDelay</code> property. This callback is a good place for your\r\n            http fetch request and post-request logic (i.e. setting isLoading false).\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>inputDelay?: number</TextHeader> - As mentioned above, this can be\r\n            set to a positive integer in order to debounce updates to the search input value\r\n            following input change events. This property directly maps to the <code>delay</code> in\r\n            milliconds passed to the <code>setTimeout</code> method.\r\n          </Li>\r\n          <Li>\r\n            <TextHeader>isLoading?: boolean</TextHeader> - When true, a loading animation will\r\n            appear in the far-right of the control and take the place of the clear icon (if shown).\r\n            Additionally, it will hide options in the menu and instead, display a loading message.\r\n            The loading message text defaults to 'Loading...', but can be overriden via\r\n            the <code>loadingMsg</code> property.\r\n          </Li>\r\n        </List>\r\n      </ListWrapper>\r\n      <SubTitle>Demo</SubTitle>\r\n      <Hr />\r\n      <Card>\r\n        <CardHeader>\r\n          <Label>Search debounced 500ms and mock HTTP call resolves after 500ms</Label>\r\n        </CardHeader>\r\n        <CardBody>\r\n          <SelectContainer>\r\n            <Select\r\n              async\r\n              isClearable\r\n              inputDelay={500}\r\n              options={options}\r\n              isLoading={isLoading}\r\n              onInputChange={onInputChange}\r\n              onSearchChange={onSearchChange}\r\n            />\r\n          </SelectContainer>\r\n        </CardBody>\r\n      </Card>\r\n    </Container>\r\n  );\r\n};",locationsMap:{"single-select":{startLoc:{col:28,line:79},endLoc:{col:1,line:164},startBody:{col:28,line:79},endBody:{col:1,line:164}},"multi-select":{startLoc:{col:27,line:166},endLoc:{col:1,line:278},startBody:{col:27,line:166},endBody:{col:1,line:278}},styling:{startLoc:{col:23,line:280},endLoc:{col:1,line:396},startBody:{col:23,line:280},endBody:{col:1,line:396}},events:{startLoc:{col:22,line:398},endLoc:{col:1,line:527},startBody:{col:22,line:398},endBody:{col:1,line:527}},methods:{startLoc:{col:23,line:529},endLoc:{col:1,line:608},startBody:{col:23,line:529},endBody:{col:1,line:608}},filtering:{startLoc:{col:25,line:610},endLoc:{col:1,line:696},startBody:{col:25,line:610},endBody:{col:1,line:696}},windowing:{startLoc:{col:25,line:698},endLoc:{col:1,line:779},startBody:{col:25,line:698},endBody:{col:1,line:779}},advanced:{startLoc:{col:24,line:781},endLoc:{col:1,line:867},startBody:{col:24,line:781},endBody:{col:1,line:867}},async:{startLoc:{col:21,line:869},endLoc:{col:1,line:951},startBody:{col:21,line:869},endBody:{col:1,line:951}}}}),title:"React Functional Select"},function SingleSelect(){var _useCallbackState=useCallbackState_useCallbackState(!1),_useCallbackState2=Object(slicedToArray.a)(_useCallbackState,2),isInvalid=_useCallbackState2[0],setIsInvalid=_useCallbackState2[1],_useCallbackState3=useCallbackState_useCallbackState(!1),_useCallbackState4=Object(slicedToArray.a)(_useCallbackState3,2),isLoading=_useCallbackState4[0],setIsLoading=_useCallbackState4[1],_useCallbackState5=useCallbackState_useCallbackState(!1),_useCallbackState6=Object(slicedToArray.a)(_useCallbackState5,2),isDisabled=_useCallbackState6[0],setIsDisabled=_useCallbackState6[1],_useCallbackState7=useCallbackState_useCallbackState(!0),_useCallbackState8=Object(slicedToArray.a)(_useCallbackState7,2),isClearable=_useCallbackState8[0],setIsClearable=_useCallbackState8[1],_useCallbackState9=useCallbackState_useCallbackState(!0),_useCallbackState10=Object(slicedToArray.a)(_useCallbackState9,2),isSearchable=_useCallbackState10[0],setIsSearchable=_useCallbackState10[1],getOptionValue=Object(react.useCallback)((function(option){return option.id}),[]),getOptionLabel=Object(react.useCallback)((function(option){return"".concat(option.city,", ").concat(option.state)}),[]);return Object(react.useEffect)((function(){isDisabled&&setIsInvalid(!1)}),[isDisabled]),Object(jsx_runtime.jsxs)(Container,{children:[Object(jsx_runtime.jsx)(Title,{children:"Single-select"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(Paragraph,{children:["In this story's source code, notice that the callback function properties ",Object(jsx_runtime.jsx)("code",{children:"getOptionValue"})," and ",Object(jsx_runtime.jsx)("code",{children:"getOptionLabel"})," are wrapped in a ",Object(jsx_runtime.jsx)("code",{children:"useCallback"}),". While not required, ",Object(jsx_runtime.jsx)("em",{children:" strongly prefer "}),"memoization of any callback function property whenever possible. This will boost performance and reduce the amount of renders as these properties are referenced in the dependency arrays of ",Object(jsx_runtime.jsx)("code",{children:"useCallbacks"}),", ",Object(jsx_runtime.jsx)("code",{children:"useEffects"}),", and ",Object(jsx_runtime.jsx)("code",{children:"useMemos"}),". When defined in a functional component, wrap in a ",Object(jsx_runtime.jsx)("code",{children:"useCallback"}),"; when defined in a legacy class component, ensure proper binding to ",Object(jsx_runtime.jsx)("code",{children:"this"}),". Alternatively, if there is no dependency on any state, you can opt to hoist functions outside of the component entirely."]}),Object(jsx_runtime.jsxs)(Paragraph,{children:["The ",Object(jsx_runtime.jsx)("code",{children:"options"})," property should also be memoized. Either consume it directly from a state management store, or make sure it is stable by avoiding inline or render-based mutations."]}),Object(jsx_runtime.jsx)(SubTitle,{children:"Demo"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(Card,{children:[Object(jsx_runtime.jsx)(CardHeader,{children:Object(jsx_runtime.jsxs)(Checkboxes,{children:[Object(jsx_runtime.jsx)(components_Checkbox,{label:"Searchable",checked:isSearchable,onCheck:setIsSearchable}),Object(jsx_runtime.jsx)(components_Checkbox,{label:"Clearable",checked:isClearable,onCheck:setIsClearable}),Object(jsx_runtime.jsx)(components_Checkbox,{label:"Disabled",checked:isDisabled,onCheck:setIsDisabled}),Object(jsx_runtime.jsx)(components_Checkbox,{label:"Invalid",checked:isInvalid,readOnly:isDisabled,onCheck:setIsInvalid}),Object(jsx_runtime.jsx)(components_Checkbox,{label:"Loading",checked:isLoading,onCheck:setIsLoading})]})}),Object(jsx_runtime.jsx)(CardBody,{children:Object(jsx_runtime.jsx)(SelectContainer,{children:Object(jsx_runtime.jsx)(Select.a,{isLoading:isLoading,isInvalid:isInvalid,options:CITY_OPTIONS,isDisabled:isDisabled,isClearable:isClearable,isSearchable:isSearchable,getOptionValue:getOptionValue,getOptionLabel:getOptionLabel})})})]})]})}),index_stories_MultiSelect=function MultiSelect(){var _useCallbackState11=useCallbackState_useCallbackState(!0),_useCallbackState12=Object(slicedToArray.a)(_useCallbackState11,2),openMenuOnClick=_useCallbackState12[0],setOpenMenuOnClick=_useCallbackState12[1],_useCallbackState13=useCallbackState_useCallbackState(!0),_useCallbackState14=Object(slicedToArray.a)(_useCallbackState13,2),closeMenuOnSelect=_useCallbackState14[0],setCloseMenuOnSelect=_useCallbackState14[1],_useCallbackState15=useCallbackState_useCallbackState(!1),_useCallbackState16=Object(slicedToArray.a)(_useCallbackState15,2),blurInputOnSelect=_useCallbackState16[0],setBlurInputOnSelect=_useCallbackState16[1],_useCallbackState17=useCallbackState_useCallbackState(!0),_useCallbackState18=Object(slicedToArray.a)(_useCallbackState17,2),hideSelectedOptions=_useCallbackState18[0],setHideSelectedOptions=_useCallbackState18[1],_useCallbackState19=useCallbackState_useCallbackState(!1),_useCallbackState20=Object(slicedToArray.a)(_useCallbackState19,2),useRenderMultiOptions=_useCallbackState20[0],setUseRenderMultiOptions=_useCallbackState20[1],getOptionValue=Object(react.useCallback)((function(option){return option.id}),[]),getOptionLabel=Object(react.useCallback)((function(option){return"".concat(option.city,", ").concat(option.state)}),[]),renderMultiOptions=Object(react.useCallback)((function(_ref){var selected=_ref.selected,renderOptionLabel=_ref.renderOptionLabel;return Object(jsx_runtime.jsxs)(react.Fragment,{children:[selected.length&&renderOptionLabel(selected[0].data),selected.length>1&&Object(jsx_runtime.jsx)(OtherSpan,{children:"(+".concat(selected.length-1," ").concat(2===selected.length?"other":"others",")")})]})}),[]);return Object(jsx_runtime.jsxs)(Container,{children:[Object(jsx_runtime.jsx)(Title,{children:"Multi-select"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(ListWrapper,{children:["Add the ",Object(jsx_runtime.jsx)("code",{children:"isMulti"})," property to allow for multiple selections. While in multi-select mode, some properties are now applicable and others become more pertinent.",Object(jsx_runtime.jsxs)(List,{children:[Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"hideSelectedOptions?: boolean"})," - Hide the selected option from the menu. Default value is false, however, if undefined and ",Object(jsx_runtime.jsx)("code",{children:"isMulti === true"}),", then its value defaults to true."]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"closeMenuOnSelect?: boolean"})," - Close the menu of options when the user selects an option. Default value is false, however, it may be benefical to set this property to true for convenience in multi-select scenarios."]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"renderMultiOptions(params: MultiParams): ReactNode"})," - Optional callback function that can be used to further customize the selection label in multi-select scenarios. ",Object(jsx_runtime.jsx)("code",{children:"params"})," is an object that contains the ",Object(jsx_runtime.jsx)("code",{children:"selected"})," and ",Object(jsx_runtime.jsx)("code",{children:"renderOptionLabel"})," properties (array of selected options and function used to render individual option labels, respectively). When this function is defined, left and right arrow navigation of individual options is disabled. When using this property, it may be be a good idea to set the property ",Object(jsx_runtime.jsx)("code",{children:"backspaceClearsValue"})," to ",Object(jsx_runtime.jsx)("em",{children:"false"})," in order to avoid accidentally clearing all selections when searching."]})]})]}),Object(jsx_runtime.jsx)(SubTitle,{children:"Demo"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(Card,{children:[Object(jsx_runtime.jsx)(CardHeader,{children:Object(jsx_runtime.jsxs)(Checkboxes,{children:[Object(jsx_runtime.jsx)(components_Checkbox,{label:"closeMenuOnSelect",checked:closeMenuOnSelect,onCheck:setCloseMenuOnSelect}),Object(jsx_runtime.jsx)(components_Checkbox,{label:"hideSelectedOptions",checked:hideSelectedOptions,onCheck:setHideSelectedOptions}),Object(jsx_runtime.jsx)(components_Checkbox,{label:"blurInputOnSelect",checked:blurInputOnSelect,onCheck:setBlurInputOnSelect}),Object(jsx_runtime.jsx)(components_Checkbox,{label:"openMenuOnClick (click caret if false)",checked:openMenuOnClick,onCheck:setOpenMenuOnClick}),Object(jsx_runtime.jsx)(components_Checkbox,{label:"renderMultiOptions (custom renderer)",checked:useRenderMultiOptions,onCheck:setUseRenderMultiOptions})]})}),Object(jsx_runtime.jsx)(CardBody,{children:Object(jsx_runtime.jsx)(SelectContainer,{children:Object(jsx_runtime.jsx)(Select.a,{isMulti:!0,isClearable:!0,isSearchable:!0,options:CITY_OPTIONS,getOptionValue:getOptionValue,getOptionLabel:getOptionLabel,openMenuOnClick:openMenuOnClick,blurInputOnSelect:blurInputOnSelect,closeMenuOnSelect:closeMenuOnSelect,hideSelectedOptions:hideSelectedOptions,backspaceClearsValue:!useRenderMultiOptions,renderMultiOptions:useRenderMultiOptions?renderMultiOptions:void 0})})})]})]})},index_stories_Styling=function Styling(){var _useState=Object(react.useState)(),_useState2=Object(slicedToArray.a)(_useState,2),themeConfig=_useState2[0],setThemeConfig=_useState2[1],_useCallbackState21=useCallbackState_useCallbackState(null),_useCallbackState22=Object(slicedToArray.a)(_useCallbackState21,2),selectedOption=_useCallbackState22[0],setSelectedOption=_useCallbackState22[1],menuItemSize=selectedOption&&selectedOption.value===ThemeEnum.LARGE_TEXT?44:35,memoizedMarkupNode=Object(react.useMemo)((function(){return Object(jsx_runtime.jsx)(components_CodeMarkup,{language:"markup",header:"Class Markup",data:CLASS_NAME_HTML})}),[]);return Object(react.useEffect)((function(){if(selectedOption){var value=selectedOption.value;setThemeConfig(ThemeConfigMap[value])}}),[selectedOption]),Object(jsx_runtime.jsxs)(Container,{children:[Object(jsx_runtime.jsx)(Title,{children:"Styling"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsx)(SubTitle,{children:"Theming"}),Object(jsx_runtime.jsxs)(Columns,{children:[Object(jsx_runtime.jsxs)(Column,{widthPercent:40,children:[Object(jsx_runtime.jsxs)(Content,{children:["react-functional-select uses ",Object(jsx_runtime.jsx)(components_PackageLink,Object(objectSpread2.a)({},STYLED_COMPONENTS_PACKAGE))," to handle its styling. The root node is wrapped in styled-component's ",Object(jsx_runtime.jsx)("code",{children:"ThemeProvider"})," wrapper component which gives all child styled-components access to the provided theme via React's context API. To override react-functional-select's default theme, pass an object to the ",Object(jsx_runtime.jsx)("code",{children:"themeConfig"})," property - any matching properties will replace those in the default theme."]}),Object(jsx_runtime.jsxs)(Content,{children:["Starting in ",Object(jsx_runtime.jsx)("strong",{children:"v2.0.0"}),", some of the nested objects in the ",Object(jsx_runtime.jsx)("code",{children:"themeConfig"})," object contain a ",Object(jsx_runtime.jsx)("code",{children:"css"})," property of type ",Object(jsx_runtime.jsx)("code",{children:"string | FlattenSimpleInterpolation | undefined"})," (default value is undefined). This property can be used to pass raw CSS styles as a string or wrapped in ",Object(jsx_runtime.jsx)(components_PackageLink,Object(objectSpread2.a)({},STYLED_COMPONENTS_PACKAGE))," exported ",Object(jsx_runtime.jsx)("code",{children:"css"})," function. Those objects are: select, control, icon, menu, noOptions, multiValue, and input."]}),Object(jsx_runtime.jsxs)(Content,{children:["Starting in ",Object(jsx_runtime.jsx)("strong",{children:"v2.7.0"}),", the control object in ",Object(jsx_runtime.jsx)("code",{children:"themeConfig"})," has the property ",Object(jsx_runtime.jsx)("code",{children:"focusedCss"})," - which is similar to the ",Object(jsx_runtime.jsx)("code",{children:"css"})," property, except that it is only applied when the select control is focused (and removed when blurred)."]})]}),Object(jsx_runtime.jsx)(Column,{widthPercent:60,children:Object(jsx_runtime.jsx)(components_CodeMarkup,{language:"javascript",data:THEME_DEFAULTS,header:"Theme Defaults",formatFn:stringifyJavaScriptObj})})]}),Object(jsx_runtime.jsx)(SubTitle,{children:"Using Classes"}),Object(jsx_runtime.jsxs)(Columns,{children:[Object(jsx_runtime.jsxs)(Column,{widthPercent:40,children:[Object(jsx_runtime.jsxs)(Content,{children:["If you want to style the component using CSS classes, set the ",Object(jsx_runtime.jsx)("code",{children:"addClassNames"})," prop to true and it will then generate ",Object(jsx_runtime.jsx)("code",{children:"className"})," attributes for that specific instance of the component. These are the classes that are available:"]}),Object(jsx_runtime.jsx)(ListWrapper,{className:"is-class-list",children:Object(jsx_runtime.jsxs)(List,{children:[Object(jsx_runtime.jsx)(Li,{children:dom.r}),Object(jsx_runtime.jsx)(Li,{children:dom.i}),Object(jsx_runtime.jsx)(Li,{children:dom.l}),Object(jsx_runtime.jsx)(Li,{children:dom.b}),Object(jsx_runtime.jsx)(Li,{children:dom.d}),Object(jsx_runtime.jsx)(Li,{children:dom.f}),Object(jsx_runtime.jsx)(Li,{children:dom.k}),Object(jsx_runtime.jsx)(Li,{children:"".concat(dom.n,", ").concat(dom.p,", ").concat(dom.q,", ").concat(dom.o)})]})})]}),Object(jsx_runtime.jsx)(Column,{widthPercent:60,children:memoizedMarkupNode})]}),Object(jsx_runtime.jsx)(SubTitle,{children:"Demo"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(Card,{children:[Object(jsx_runtime.jsx)(CardHeader,{children:Object(jsx_runtime.jsx)(styled_Label,{children:"Try selecting different themes"})}),Object(jsx_runtime.jsx)(CardBody,{children:Object(jsx_runtime.jsxs)(Columns,{children:[Object(jsx_runtime.jsx)(Column,{widthPercent:40,children:Object(jsx_runtime.jsx)("div",{style:{marginTop:"1rem"},children:Object(jsx_runtime.jsx)(Select.a,{isClearable:!1,isSearchable:!1,options:THEME_OPTIONS,themeConfig:themeConfig,menuItemSize:menuItemSize,initialValue:THEME_OPTIONS[0],onOptionChange:setSelectedOption})})}),Object(jsx_runtime.jsx)(Column,{widthPercent:60,children:Object(jsx_runtime.jsx)(components_CodeMarkup,{data:themeConfig,language:"javascript",header:"theme-config",formatFn:stringifyJavaScriptObj})})]})})]})]})},index_stories_Events=function Events(){var options=Object(react.useMemo)((function(){return createSelectOptions(5)}),[]),_useCallbackState23=useCallbackState_useCallbackState(!1),_useCallbackState24=Object(slicedToArray.a)(_useCallbackState23,2),addOnKeyDown=_useCallbackState24[0],setAddOnKeyDown=_useCallbackState24[1],_useCallbackState25=useCallbackState_useCallbackState(!0),_useCallbackState26=Object(slicedToArray.a)(_useCallbackState25,2),addOnMenuOpen=_useCallbackState26[0],setAddOnMenuOpen=_useCallbackState26[1],_useCallbackState27=useCallbackState_useCallbackState(!1),_useCallbackState28=Object(slicedToArray.a)(_useCallbackState27,2),addOnMenuClose=_useCallbackState28[0],setAddOnMenuClose=_useCallbackState28[1],_useCallbackState29=useCallbackState_useCallbackState(!1),_useCallbackState30=Object(slicedToArray.a)(_useCallbackState29,2),addOnInputBlur=_useCallbackState30[0],setAddOnInputBlur=_useCallbackState30[1],_useCallbackState31=useCallbackState_useCallbackState(!1),_useCallbackState32=Object(slicedToArray.a)(_useCallbackState31,2),addOnInputFocus=_useCallbackState32[0],setAddOnInputFocus=_useCallbackState32[1],_useCallbackState33=useCallbackState_useCallbackState(!0),_useCallbackState34=Object(slicedToArray.a)(_useCallbackState33,2),addOnOptionChange=_useCallbackState34[0],setAddOnOptionChange=_useCallbackState34[1],onOptionChange=Object(react.useCallback)((function(option){var optionJsonStr=JSON.stringify(option||{}).replace(/"/g,"'");utils_renderInfoToast("Selected Option: ".concat(optionJsonStr))}),[]),onMenuOpen=Object(react.useCallback)((function(){return utils_renderInfoToast("Menu opened!")}),[]),onMenuClose=Object(react.useCallback)((function(){return utils_renderInfoToast("Menu closed!")}),[]),onInputBlur=Object(react.useCallback)((function(){return utils_renderInfoToast("Control blurred!")}),[]),onInputFocus=Object(react.useCallback)((function(){return utils_renderInfoToast("Control focused!")}),[]),onKeyDown=Object(react.useCallback)((function(){return utils_renderInfoToast("keydown event executed!")}),[]);return Object(react.useEffect)((function(){return react_toastify_esm.a.configure(TOAST_CONTAINER_PROPS),function(){react_toastify_esm.a.dismiss()}}),[]),Object(jsx_runtime.jsxs)(Container,{children:[Object(jsx_runtime.jsx)(Title,{children:"Events"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(ListWrapper,{children:["There are various callback function properties that are executed following their associated events:",Object(jsx_runtime.jsxs)(List,{children:[Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"onOptionChange(data: any): void"})," - executed after an option is selected or removed"]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"onMenuOpen(...args: any[]): void"})," - executed after the menu is opened"]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"onMenuClose(...args: any[]): void"})," - executed after the menu is closed"]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"onInputChange(value: string): void"})," - executed after the input control's value changes"]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"onInputBlur(e: FocusEvent<HTMLInputElement>): void"})," - executed after the input control is blurred"]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"onInputFocus(e: FocusEvent<HTMLInputElement>): void"})," - executed after the input control is focused"]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"onKeyDown(e: KeyboardEvent<HTMLDivElement>, input?: string, focusedOption?: FocusedOption): void"})," - executed after the onKeyDown event"]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"onSearchChange(value: string): void"})," - executed after the input value is persisted to state; this value also evaluates the ",Object(jsx_runtime.jsx)("code",{children:"inputDelay"})," property for debouncing - this callback is really only useful when ",Object(jsx_runtime.jsx)("code",{children:"inputDelay"})," is defined, and if not, it probably makes more sense to use the ",Object(jsx_runtime.jsx)("code",{children:"onInputChange"})," callback"]})]})]}),Object(jsx_runtime.jsx)(SubTitle,{children:"Demo"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(Card,{children:[Object(jsx_runtime.jsxs)(CardHeader,{children:[Object(jsx_runtime.jsx)(styled_Label,{children:"Events trigger a toast notification"}),Object(jsx_runtime.jsxs)(Checkboxes,{children:[Object(jsx_runtime.jsx)(components_Checkbox,{label:"onOptionChange",checked:addOnOptionChange,onCheck:setAddOnOptionChange}),Object(jsx_runtime.jsx)(components_Checkbox,{label:"onMenuOpen",checked:addOnMenuOpen,onCheck:setAddOnMenuOpen}),Object(jsx_runtime.jsx)(components_Checkbox,{label:"onMenuClose",checked:addOnMenuClose,onCheck:setAddOnMenuClose}),Object(jsx_runtime.jsx)(components_Checkbox,{label:"onInputBlur",checked:addOnInputBlur,onCheck:setAddOnInputBlur}),Object(jsx_runtime.jsx)(components_Checkbox,{label:"onInputFocus",checked:addOnInputFocus,onCheck:setAddOnInputFocus}),Object(jsx_runtime.jsx)(components_Checkbox,{label:"onKeyDown",checked:addOnKeyDown,onCheck:setAddOnKeyDown})]})]}),Object(jsx_runtime.jsx)(CardBody,{children:Object(jsx_runtime.jsx)(SelectContainer,{children:Object(jsx_runtime.jsx)(Select.a,{options:options,onKeyDown:addOnKeyDown?onKeyDown:void 0,onMenuOpen:addOnMenuOpen?onMenuOpen:void 0,onMenuClose:addOnMenuClose?onMenuClose:void 0,onInputBlur:addOnInputBlur?onInputBlur:void 0,onInputFocus:addOnInputFocus?onInputFocus:void 0,onOptionChange:addOnOptionChange?onOptionChange:void 0})})})]})]})},index_stories_Methods=function Methods(){var selectRef=Object(react.useRef)(null),options=Object(react.useMemo)((function(){return createSelectOptions(5)}),[]);return Object(jsx_runtime.jsxs)(Container,{children:[Object(jsx_runtime.jsx)(Title,{children:"Methods"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(ListWrapper,{children:["Five public methods are exposed to wrapping components and are accessible via a forwarded ",Object(jsx_runtime.jsx)("code",{children:"ref"}),".",Object(jsx_runtime.jsxs)(List,{children:[Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"blur(): void"})," - blur the control programatically"]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"focus(): void"})," - focus the control programatically"]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"toggleMenu(state?: boolean): void"})," - toggle the menu programatically"]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"clearValue(): void"})," - clear the current value programatically ",Object(jsx_runtime.jsx)("em",{children:"(if an option is selected)"})]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"setValue(option?: any): void"})," - set the value programatically ",Object(jsx_runtime.jsx)("em",{children:"(option will be validated)"})]})]})]}),Object(jsx_runtime.jsx)(SubTitle,{children:"Demo"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(Card,{children:[Object(jsx_runtime.jsxs)(CardHeader,{children:[Object(jsx_runtime.jsx)(styled_Label,{children:"Methods"}),Object(jsx_runtime.jsxs)(Buttons,{children:[Object(jsx_runtime.jsx)(Button,{onClick:function focusSelect(){selectRef.current&&selectRef.current.focus()},children:"Focus"}),Object(jsx_runtime.jsx)(Button,{onClick:function blurSelect(){selectRef.current&&selectRef.current.blur()},children:"Blur"}),Object(jsx_runtime.jsx)(Button,{onClick:function toggleMenuOpen(){selectRef.current&&selectRef.current.toggleMenu(!0)},children:"Open Menu"}),Object(jsx_runtime.jsx)(Button,{onClick:function clearValue(){selectRef.current&&selectRef.current.clearValue()},children:"Clear Value"}),Object(jsx_runtime.jsx)(Button,{onClick:function updateSelectedOption(){selectRef.current&&selectRef.current.setValue(options[0])},children:"Set Value (1st Option)"})]})]}),Object(jsx_runtime.jsx)(CardBody,{children:Object(jsx_runtime.jsx)(SelectContainer,{children:Object(jsx_runtime.jsx)(Select.a,{ref:selectRef,options:options,initialValue:options[0]})})})]})]})},index_stories_Filtering=function Filtering(){var _useCallbackState35=useCallbackState_useCallbackState(!0),_useCallbackState36=Object(slicedToArray.a)(_useCallbackState35,2),filterIgnoreCase=_useCallbackState36[0],setFilterIgnoreCase=_useCallbackState36[1],_useCallbackState37=useCallbackState_useCallbackState(!1),_useCallbackState38=Object(slicedToArray.a)(_useCallbackState37,2),useCustomFilterFunc=_useCallbackState38[0],setUseCustomFilterFunc=_useCallbackState38[1],_useCallbackState39=useCallbackState_useCallbackState(!1),_useCallbackState40=Object(slicedToArray.a)(_useCallbackState39,2),filterIgnoreAccents=_useCallbackState40[0],setFilterIgnoreAccents=_useCallbackState40[1],_useCallbackState41=useCallbackState_useCallbackState(!1),_useCallbackState42=Object(slicedToArray.a)(_useCallbackState41,2),filterMatchFromStart=_useCallbackState42[0],setFilterMatchFromStart=_useCallbackState42[1],getOptionValue=Object(react.useCallback)((function(option){return option.id}),[]),getOptionLabel=Object(react.useCallback)((function(option){return"".concat(option.city,", ").concat(option.state)}),[]),getFilterOptionString=Object(react.useCallback)((function(menuOption){return menuOption.data.state}),[]),options=Object(react.useMemo)((function(){return[].concat(Object(toConsumableArray.a)(CITY_OPTIONS),[{id:11,city:"So Paulo",state:"BR"}])}),[]);return Object(jsx_runtime.jsxs)(Container,{children:[Object(jsx_runtime.jsx)(Title,{children:"Filter Customization"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(ListWrapper,{children:["The default filtering functionality can be customized via the following properties:",Object(jsx_runtime.jsxs)(List,{children:[Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"filterIgnoreCase?: boolean"})," - Filter ignores case when matching strings. Default value is ",Object(jsx_runtime.jsx)("code",{children:"true"}),"."]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"filterIgnoreAccents?: boolean"})," - Filter ignores accents when matching strings. Default value is ",Object(jsx_runtime.jsx)("code",{children:"false"}),"."]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"filterMatchFrom?: 'any' | 'start'"})," - Position in source string to perform match. Default value is ",Object(jsx_runtime.jsx)("code",{children:"'any'"}),"."]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"getFilterOptionString(option: MenuOption): string"})," - When defined will take each option and generate a string used in the filtering process. By default, the stringified version of what is generated by ",Object(jsx_runtime.jsx)("code",{children:"getOptionLabel"}),", if definded, or the option's label as a fallback. The ",Object(jsx_runtime.jsx)("code",{children:"MenuOption"})," typed parameter that ",Object(jsx_runtime.jsx)("code",{children:"getFilterOptionString"})," accepts contains a ",Object(jsx_runtime.jsx)("code",{children:"data"})," property that represents the objects that comprise your ",Object(jsx_runtime.jsx)("code",{children:"options"})," property."]})]})]}),Object(jsx_runtime.jsx)(SubTitle,{children:"Demo"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(Card,{children:[Object(jsx_runtime.jsx)(CardHeader,{children:Object(jsx_runtime.jsxs)(Checkboxes,{children:[Object(jsx_runtime.jsx)(components_Checkbox,{label:"Ignore Case",checked:filterIgnoreCase,onCheck:setFilterIgnoreCase}),Object(jsx_runtime.jsx)(components_Checkbox,{label:"Ignore Accents",checked:filterIgnoreAccents,onCheck:setFilterIgnoreAccents}),Object(jsx_runtime.jsx)(components_Checkbox,{label:"Match from the start",checked:filterMatchFromStart,onCheck:setFilterMatchFromStart}),Object(jsx_runtime.jsx)(components_Checkbox,{label:"Use custom filter function (by state only)",checked:useCustomFilterFunc,onCheck:setUseCustomFilterFunc})]})}),Object(jsx_runtime.jsx)(CardBody,{children:Object(jsx_runtime.jsx)(SelectContainer,{children:Object(jsx_runtime.jsx)(Select.a,{isClearable:!0,options:options,getOptionValue:getOptionValue,getOptionLabel:getOptionLabel,filterIgnoreCase:filterIgnoreCase,filterIgnoreAccents:filterIgnoreAccents,getFilterOptionString:useCustomFilterFunc?getFilterOptionString:void 0,filterMatchFrom:filterMatchFromStart?enums.a.START:enums.a.ANY})})})]})]})},index_stories_Windowing=function Windowing(){var optionCountList=[100,1e3,5e3,25e3,5e4],selectRef=Object(react.useRef)(null),_useState3=Object(react.useState)([]),_useState4=Object(slicedToArray.a)(_useState3,2),options=_useState4[0],setOptions=_useState4[1],_useState5=Object(react.useState)(optionCountList[0]),_useState6=Object(slicedToArray.a)(_useState5,2),optionsCount=_useState6[0],setOptionsCount=_useState6[1];return Object(useUpdateEffect.a)((function(){selectRef.current&&selectRef.current.clearValue()}),[options]),Object(react.useEffect)((function(){var nextSelectOptions=createSelectOptions(optionsCount);setOptions(nextSelectOptions)}),[optionsCount]),Object(jsx_runtime.jsxs)(Container,{children:[Object(jsx_runtime.jsx)(Title,{children:"Integrated Windowing"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(ListWrapper,{children:["Option data is 'windowed' using the"," ",Object(jsx_runtime.jsx)(components_PackageLink,Object(objectSpread2.a)({},REACT_WINDOW_PACKAGE))," package. Aside from the obvious benefits provided by only rendering a small subset of your enumerable data (rather than bloating the DOM with an excessive amount of nodes), 'windowing' can also assist with:",Object(jsx_runtime.jsxs)(List,{children:[Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)("strong",{children:"Efficient memory allocation"}),". 'Windowing' naturally lends itself to the dynamic generation of attributes/values as each object comes into your renderer's scope (as opposed to allocating this data upfront for each object in your list). This way you can perform this work just when you absolutely need to and then can immediately release it for the GC to cleanup. As an example I am generating the ",Object(jsx_runtime.jsx)("code",{children:"onClick"}),", ",Object(jsx_runtime.jsx)("code",{children:"id"}),", and"," ",Object(jsx_runtime.jsx)("code",{children:"className"})," attributes for each ",Object(jsx_runtime.jsx)("code",{children:"menuOption"})," ","as they get passed to the ",Object(jsx_runtime.jsx)("code",{children:"<Option />"})," renderer component."]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)("strong",{children:"Functional architecture"}),". The flexibility provided through only having to manage subsets of your list allows for a more dynamic application. By breaking your code out into smaller, 'pure' child components, you can write code that scales well and becomes open to performance optimizations - most notably, memoization. Simple components that rely on the props passed to it (rather than its own managed state) to generate its JSX are likely candidates for memoization (testing & debugging becomes much easier as well)."]})]}),Object(jsx_runtime.jsx)("em",{children:"Note: "}),"The only time any noticeable performance degradation will be observed is during search input updates when the ",Object(jsx_runtime.jsx)("code",{children:"options"})," ","count reaches the high tens of thousands. To work around this, the"," ",Object(jsx_runtime.jsx)("code",{children:"inputDelay"})," (number in milliseconds) can be set to debounce the input value. That way, the ",Object(jsx_runtime.jsx)("code",{children:"menuOptions"})," will not be recalculated on every keystroke."]}),Object(jsx_runtime.jsx)(SubTitle,{children:"Demo"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(Card,{children:[Object(jsx_runtime.jsxs)(CardHeader,{children:[Object(jsx_runtime.jsx)(styled_Label,{children:"Options Count"}),Object(jsx_runtime.jsx)(Buttons,{children:optionCountList.map((function(count){return Object(jsx_runtime.jsx)(components_OptionsCountButton,{count:count,optionsCount:optionsCount,setOptionsCount:setOptionsCount},count)}))})]}),Object(jsx_runtime.jsx)(CardBody,{children:Object(jsx_runtime.jsx)(SelectContainer,{children:Object(jsx_runtime.jsx)(Select.a,{ref:selectRef,options:options})})})]})]})},index_stories_Advanced=function Advanced(){var getOptionValue=Object(react.useCallback)((function(option){return option.id}),[]),getIsOptionDisabled=Object(react.useCallback)((function(option){return option.name===PACKAGE_OPTIONS[3].name}),[]),renderOptionLabel=Object(react.useCallback)((function(option){return Object(jsx_runtime.jsxs)(OptionContainer,{children:[Object(jsx_runtime.jsxs)(ReactSvg,{"aria-hidden":"true",viewBox:"0 0 841.9 595.3",isDisabled:getIsOptionDisabled(option),children:[Object(jsx_runtime.jsx)("path",{d:"M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"}),Object(jsx_runtime.jsx)("circle",{cx:"420.9",cy:"296.5",r:"45.7"})]}),Object(jsx_runtime.jsx)(OptionName,{children:option.name})]})}),[getIsOptionDisabled]),customCaretIcon=Object(react.useCallback)((function(_ref2){var menuOpen=_ref2.menuOpen;return Object(jsx_runtime.jsx)(ChevronDownSvg,{menuOpen:menuOpen,"aria-hidden":"true",viewBox:"0 0 448 512",children:Object(jsx_runtime.jsx)("path",{d:"M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"})})}),[]);return Object(jsx_runtime.jsxs)(Container,{children:[Object(jsx_runtime.jsx)(Title,{children:"Advanced Customization"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(ListWrapper,{children:["Implementation using a couple of the more specialized properties.",Object(jsx_runtime.jsxs)(List,{children:[Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"renderOptionLabel(option: any): React.ReactNode"})," - Callback function with a return type of ",Object(jsx_runtime.jsx)("code",{children:"ReactNode"}),". Use this property in cases where the standard ",Object(jsx_runtime.jsx)("code",{children:"getOptionLabel"})," property won't meet your needs (for instance, you want to render each option's label using custom JSX). More complex option labels will likely equate to longer render durations - this can translate into a flash of empty space when a user first starts scrolling. In order to prevent this, the ",Object(jsx_runtime.jsx)("code",{children:"menuOverscanCount"})," property can be increased to render additional rows outside of the visible area. The default value for this property is 1 and it is important to note that increasing this value can negatively impact performance."]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"getIsOptionDisabled(option: any): boolean"})," - Callback function with a return type of ",Object(jsx_runtime.jsx)("code",{children:"Boolean"}),". When it evaluates to a value of true, that option iteration will be rendered ",Object(jsx_runtime.jsx)("em",{children:"disabled"}),". As an alternative, you can also pass a property of ",Object(jsx_runtime.jsx)("code",{children:"isDisabled"})," with each option. Use of these two options - they cannot both be specified."]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"caretIcon: ReactNode | (...args: any[]) => ReactNode"})," - A custom node or a function that returns a node can used for the ",Object(jsx_runtime.jsx)("code",{children:"caretIcon"})," property. When using a function, an object containing stateful data is forwarded and can be used to style your custom node accordingly. The state is ",Object(jsx_runtime.jsx)("code",{children:"{ menuOpen, isLoading, isInvalid, isDisabled }"})," of type ",Object(jsx_runtime.jsx)("code",{children:"Record<string, boolean>"}),". The ",Object(jsx_runtime.jsx)("code",{children:"clearIcon"})," property has an identical definition."]})]})]}),Object(jsx_runtime.jsx)(SubTitle,{children:"Demo"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(Card,{children:[Object(jsx_runtime.jsx)(CardHeader,{children:Object(jsx_runtime.jsx)(styled_Label,{children:"JSX labels, custom caret icon, and disabled option"})}),Object(jsx_runtime.jsx)(CardBody,{children:Object(jsx_runtime.jsx)(SelectContainer,{children:Object(jsx_runtime.jsx)(Select.a,{isSearchable:!1,options:PACKAGE_OPTIONS,themeConfig:THEME_CONFIG,caretIcon:customCaretIcon,getOptionValue:getOptionValue,renderOptionLabel:renderOptionLabel,getIsOptionDisabled:getIsOptionDisabled})})})]})]})},index_stories_Async=function Async(){var _useState7=Object(react.useState)(!1),_useState8=Object(slicedToArray.a)(_useState7,2),isLoading=_useState8[0],setIsLoading=_useState8[1],_useState9=Object(react.useState)((function(){return createAsyncOptions(5,"Initial")})),_useState10=Object(slicedToArray.a)(_useState9,2),options=_useState10[0],setOptions=_useState10[1],onInputChange=Object(react.useCallback)((function(){return setIsLoading(!0)}),[]),onSearchChange=Object(react.useCallback)((function(value){(function mockHttpRequest(){return _mockHttpRequest.apply(this,arguments)})().then((function(){var nextOptions=createAsyncOptions(function getRandomInt(min,max){return Math.floor(Math.random()*(max-min+1))+min}(1,5),"Search text: ".concat(value||"Initial"));setOptions(nextOptions)})).catch((function(err){return console.error(err)})).then((function(){return setIsLoading(!1)}))}),[]);return Object(jsx_runtime.jsxs)(Container,{children:[Object(jsx_runtime.jsx)(Title,{children:"Async Mode"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(ListWrapper,{children:["Add the ",Object(jsx_runtime.jsx)("code",{children:"async"})," property to enable async mode. There is one key difference in core functionality with async mode - changes to search input value will not cause the ",Object(jsx_runtime.jsx)("code",{children:"useMenuOptions"})," effect to run. The rest of hooking into async mode is achieved using some combination of the properties found below. ",Object(jsx_runtime.jsx)("em",{children:"Properties onInputChange and onSearchChange should be memoized."}),Object(jsx_runtime.jsxs)(List,{children:[Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"onInputChange(value: string): void"})," - callback executed directly following the input control's ",Object(jsx_runtime.jsx)("code",{children:"onChange"})," event. This callback is not debounced, so it fires immediately. This is a good place to set a stateful loading property in your parent component that is mapped to react-functional-select's ",Object(jsx_runtime.jsx)("code",{children:"isLoading"})," property."]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"onSearchChange(value: string): void"})," - callback executed following component state updates for the ",Object(jsx_runtime.jsx)("code",{children:"debouncedInputValue"}),". The debounce is set using the ",Object(jsx_runtime.jsx)("code",{children:"inputDelay"})," property. This callback is a good place for your http fetch request and post-request logic (i.e. setting isLoading false)."]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"inputDelay?: number"})," - As mentioned above, this can be set to a positive integer in order to debounce updates to the search input value following input change events. This property directly maps to the ",Object(jsx_runtime.jsx)("code",{children:"delay"})," in milliconds passed to the ",Object(jsx_runtime.jsx)("code",{children:"setTimeout"})," method."]}),Object(jsx_runtime.jsxs)(Li,{children:[Object(jsx_runtime.jsx)(TextHeader,{children:"isLoading?: boolean"})," - When true, a loading animation will appear in the far-right of the control and take the place of the clear icon (if shown). Additionally, it will hide options in the menu and instead, display a loading message. The loading message text defaults to 'Loading...', but can be overriden via the ",Object(jsx_runtime.jsx)("code",{children:"loadingMsg"})," property."]})]})]}),Object(jsx_runtime.jsx)(SubTitle,{children:"Demo"}),Object(jsx_runtime.jsx)(Hr,{}),Object(jsx_runtime.jsxs)(Card,{children:[Object(jsx_runtime.jsx)(CardHeader,{children:Object(jsx_runtime.jsx)(styled_Label,{children:"Search debounced 500ms and mock HTTP call resolves after 500ms"})}),Object(jsx_runtime.jsx)(CardBody,{children:Object(jsx_runtime.jsx)(SelectContainer,{children:Object(jsx_runtime.jsx)(Select.a,{async:!0,isClearable:!0,inputDelay:500,options:options,isLoading:isLoading,onInputChange:onInputChange,onSearchChange:onSearchChange})})})]})]})}},941:function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__);var jsx_runtime=__webpack_require__(0),react_dom=__webpack_require__(50),react_dom_default=__webpack_require__.n(react_dom),taggedTemplateLiteral=__webpack_require__(3),styled_components_browser_esm=__webpack_require__(2);function _templateObject4(){var data=Object(taggedTemplateLiteral.a)(["\n  .Toastify__toast-container {\n    z-index: 9999;\n    position: fixed;\n    padding: 4px;\n    width: 320px;\n    box-sizing: border-box;\n    color: #fff;\n    &--top-right {\n      top: 1em;\n      right: 1em;\n    }\n\n    @media only screen and (max-width: 480px) {\n      width: 100vw;\n      padding: 0;\n      left: 0;\n      margin: 0;\n      &--top-right {\n        top: 0;\n      }\n    }\n\n    .Toastify__toast {\n      position: relative;\n      min-height: 64px;\n      box-sizing: border-box;\n      margin-bottom: 1rem;\n      padding: 8px;\n      border-radius: 3px;\n      box-shadow: 0 1px 10px 0 rgba(0, 0, 0, 0.1), 0 2px 15px 0 rgba(0, 0, 0, 0.05);\n      display: flex;\n      justify-content: space-between;\n      max-height: 800px;\n      overflow: hidden;\n      font-size: 1.075rem;\n      font-weight: 400;\n      font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;\n      cursor: pointer;\n      direction: ltr;\n      &--default {\n        background: #fff;\n        color: #aaa;\n      }\n      &--info {\n        color: #fff;\n        background: #149df3;\n      }\n      &-body {\n        flex: 1;\n        margin: auto 0 auto 0.75rem;\n      }\n\n      @media only screen and (max-width: 480px) {\n        font-size: 1rem;\n        border-radius: 0;\n        margin-bottom: 0.25rem;\n      }\n    }\n\n    .Toastify__close-button {\n      color: #fff;\n      background: transparent;\n      outline: none;\n      border: none;\n      padding: 0;\n      cursor: pointer;\n      opacity: 0.7;\n      transition: 0.3s ease;\n      align-self: flex-start;\n      &--default {\n        color: #000;\n        opacity: 0.3;\n      }\n      & > svg {\n        fill: currentColor;\n        height: 16px;\n        width: 14px;\n        font-weight: 700;\n      }\n      &:hover,\n      &:focus {\n        opacity: 1;\n      }\n    }\n\n    .Toastify__progress-bar {\n      position: absolute;\n      bottom: 0;\n      left: 0;\n      width: 100%;\n      height: 5px;\n      z-index: 9999;\n      opacity: 0.7;\n      background-color: rgba(255, 255, 255, 0.7);\n      transform-origin: left;\n      &--animated {\n        animation: "," linear 1 forwards;\n      }\n      &--controlled {\n        transition: transform 0.2s;\n      }\n      &--default {\n        background: linear-gradient(\n          to right,\n          #4cd964,\n          #5ac8fa,\n          #007aff,\n          #34aadc,\n          #5856d6,\n          #ff2d55\n        );\n      }\n    }\n  }\n\n  .Toastify__bounce-enter {\n    &--top-right {\n      animation-name: ",";\n    }\n  }\n\n  .Toastify__bounce-exit {\n    &--top-right {\n      animation-name: ",";\n    }\n  }\n"]);return _templateObject4=function _templateObject4(){return data},data}function _templateObject3(){var data=Object(taggedTemplateLiteral.a)(["\n  from,\n  60%,\n  75%,\n  90%,\n  to {\n    animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);\n  } from {\n    opacity: 0;\n    transform: translate3d(3000px, 0, 0);\n  } 60% {\n    opacity: 1;\n    transform: translate3d(-25px, 0, 0);\n  } 75% {\n    transform: translate3d(10px, 0, 0);\n  } 90% {\n    transform: translate3d(-5px, 0, 0);\n  } to {\n    transform: none;\n  }\n"]);return _templateObject3=function _templateObject3(){return data},data}function _templateObject2(){var data=Object(taggedTemplateLiteral.a)(["\n  20% {\n    opacity: 1;\n    transform: translate3d(-20px, 0, 0);\n  } to {\n    opacity: 0;\n    transform: translate3d(2000px, 0, 0);\n  }\n"]);return _templateObject2=function _templateObject2(){return data},data}function _templateObject(){var data=Object(taggedTemplateLiteral.a)(["\n  0% {\n    transform: scaleX(1);\n  } 100% {\n    transform: scaleX(0);\n  }\n"]);return _templateObject=function _templateObject(){return data},data}var _toastify_trackProgress=Object(styled_components_browser_esm.e)(_templateObject()),_toastify_bounceOutRight=Object(styled_components_browser_esm.e)(_templateObject2()),_toastify_bounceInRight=Object(styled_components_browser_esm.e)(_templateObject3()),react_toastify_css=Object(styled_components_browser_esm.c)(_templateObject4(),_toastify_trackProgress,_toastify_bounceInRight,_toastify_bounceOutRight);function global_style_templateObject(){var data=Object(taggedTemplateLiteral.a)(["\n  *,\n  *::before,\n  *::after {\n    box-sizing: border-box;\n  }\n\n  html {\n    line-height: 1.15;\n    text-size-adjust: 100%;\n    text-rendering: optimizeLegibility;\n    -moz-osx-font-smoothing: grayscale;\n    -webkit-font-smoothing: antialiased;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  }\n\n  body {\n    flex: 1;\n    margin: 0;\n    display: flex;\n    font-size: 1rem;\n    font-weight: 400;\n    text-align: left;\n    line-height: 1.5;\n    min-height: 120vh;\n    padding: 1rem 0.25rem !important;\n    flex-direction: column;\n    background-color: #fff;\n    color: rgba(0, 0, 0, 0.87);\n    font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;\n  }\n\n  em {\n    font-weight: 600;\n  }\n\n  strong {\n    color: black;\n    font-weight: 600;\n    font-size: 1.025em;\n  }\n\n  code {\n    font-size: 88%;\n    border-radius: 3px;\n    word-break: break-word;\n    padding: .15em .2em .15em;\n    color: rgba(0, 0, 0, 0.87);\n    background-color: rgba(30, 167, 253, 0.115);\n    font-family: source-code-pro, Menlo, Monaco, Consolas, Courier New, monospace;\n\n    @media only screen and (max-width: 525px) {\n      padding: .1em .25em .1em;\n    }\n  }\n\n  ","\n"]);return global_style_templateObject=function _templateObject(){return data},data}var el,GlobalStyle=Object(styled_components_browser_esm.b)(global_style_templateObject(),react_toastify_css),_globalStyleEl=document.getElementById("temp2-global-style")||((el=document.createElement("div")).id="temp2-global-style",document.head.appendChild(el),el);react_dom_default.a.render(Object(jsx_runtime.jsx)(GlobalStyle,{}),_globalStyleEl,(function completeSetupDOM(){_globalStyleEl&&document.head.removeChild(_globalStyleEl)}))},952:function(module,exports,__webpack_require__){__webpack_require__(407),__webpack_require__(709),__webpack_require__(710),__webpack_require__(901),module.exports=__webpack_require__(904)}}]);
//# sourceMappingURL=main~24120820.96a2e63ce5202e384f7c.bundle.js.map